/*
Lichess.org API reference

# Introduction Welcome to the reference for the Lichess API! Lichess is free/libre, open-source chess server powered by volunteers and donations. - Get help in the [Lichess Discord channel](https://discord.gg/lichess) - API demo app with OAuth2 login, gameplay, and more: [source](https://github.com/lichess-org/api-demo) / [demo](https://lichess-org.github.io/api-demo/) - [Contribute to this documentation on Github](https://github.com/lichess-org/api) - Check out [Lichess widgets to embed in your website](https://lichess.org/developers) - [Download all Lichess rated games](https://database.lichess.org/) - [Download all Lichess puzzles with themes, ratings and votes](https://database.lichess.org/#puzzles)  ## Endpoint All requests go to `https://lichess.org` (unless otherwise specified).  ## Clients - [Python general API](https://github.com/ZackClements/berserk) - [MicroPython general API](https://github.com/mkomon/uberserk) - [Python general API - async](https://pypi.org/project/async-lichess-sdk) - [Python Lichess Bot](https://github.com/ShailChoksi/lichess-bot) - [Python Board API for Certabo](https://github.com/haklein/certabo-lichess) - [Java general API](https://github.com/tors42/chariot)  ## Rate limiting All requests are rate limited using various strategies, to ensure the API remains responsive for everyone. Only make one request at a time. If you receive an HTTP response with a [429 status](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429), please wait a full minute before resuming API usage.  ## Streaming with ND-JSON Some API endpoints stream their responses as [Newline Delimited JSON a.k.a. **nd-json**](http://ndjson.org/), with one JSON object per line.  Here's a [JavaScript utility function](https://gist.github.com/ornicar/a097406810939cf7be1df8ea30e94f3e) to help reading NDJSON streamed responses.

API version: 2.0.0
Contact: contact@lichess.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// ArenaTournamentsApiService ArenaTournamentsApi service
type ArenaTournamentsApiService service

type ArenaApiTeamArenaRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
	teamId     interface{}
	max        *interface{}
}

// How many tournaments to download.
func (r ArenaApiTeamArenaRequest) Max(max interface{}) ArenaApiTeamArenaRequest {
	r.max = &max
	return r
}

func (r ArenaApiTeamArenaRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiTeamArenaExecute(r)
}

/*
ApiTeamArena Get team Arena tournaments

Get all Arena tournaments relevant to a team.

Tournaments are sorted by reverse chronological order of start date (last starting first).

Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId ID of the team
 @return ArenaApiTeamArenaRequest
*/
func (a *ArenaTournamentsApiService) ApiTeamArena(ctx context.Context, teamId interface{}) ArenaApiTeamArenaRequest {
	return ArenaApiTeamArenaRequest{
		ApiService: a,
		ctx:        ctx,
		teamId:     teamId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ArenaTournamentsApiService) ApiTeamArenaExecute(r ArenaApiTeamArenaRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.ApiTeamArena")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/team/{teamId}/arena"
	localVarPath = strings.Replace(localVarPath, "{"+"teamId"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		localVarQueryParams.Add("max", parameterToString(*r.max, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiTournamentRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
}

func (r ApiApiTournamentRequest) Execute() (*ArenaTournaments, *http.Response, error) {
	return r.ApiService.ApiTournamentExecute(r)
}

/*
ApiTournament Get current tournaments

Get recently finished, ongoing, and upcoming tournaments.

This API is used to display the [Lichess tournament schedule](https://lichess.org/tournament).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiTournamentRequest
*/
func (a *ArenaTournamentsApiService) ApiTournament(ctx context.Context) ApiApiTournamentRequest {
	return ApiApiTournamentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ArenaTournaments
func (a *ArenaTournamentsApiService) ApiTournamentExecute(r ApiApiTournamentRequest) (*ArenaTournaments, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ArenaTournaments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.ApiTournament")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiTournamentJoinRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
	id         interface{}
	password   *interface{}
	team       *interface{}
	pairMeAsap *interface{}
}

// The tournament password, if one is required. Can also be a [user-specific entry code](https://github.com/lichess-org/api/tree/master/example/tournament-entry-code) generated and shared by the organizer.
func (r ApiApiTournamentJoinRequest) Password(password interface{}) ApiApiTournamentJoinRequest {
	r.password = &password
	return r
}

// The team to join the tournament with, for team battle tournaments
func (r ApiApiTournamentJoinRequest) Team(team interface{}) ApiApiTournamentJoinRequest {
	r.team = &team
	return r
}

// If the tournament is started, attempt to pair the user, even if they are not connected to the tournament page. This expires after one minute, to avoid pairing a user who is long gone. You may call \\\&quot;join\\\&quot; again to extend the waiting.
func (r ApiApiTournamentJoinRequest) PairMeAsap(pairMeAsap interface{}) ApiApiTournamentJoinRequest {
	r.pairMeAsap = &pairMeAsap
	return r
}

func (r ApiApiTournamentJoinRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.ApiTournamentJoinExecute(r)
}

/*
ApiTournamentJoin Join an Arena tournament

Join an Arena tournament, possibly with a password and/or a team.
Also unpauses if you had previously [paused](#operation/apiTournamentWithdraw) the tournament.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiApiTournamentJoinRequest
*/
func (a *ArenaTournamentsApiService) ApiTournamentJoin(ctx context.Context, id interface{}) ApiApiTournamentJoinRequest {
	return ApiApiTournamentJoinRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return Ok
func (a *ArenaTournamentsApiService) ApiTournamentJoinExecute(r ApiApiTournamentJoinRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.ApiTournamentJoin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament/{id}/join"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.password != nil {
		localVarFormParams.Add("password", parameterToString(*r.password, ""))
	}
	if r.team != nil {
		localVarFormParams.Add("team", parameterToString(*r.team, ""))
	}
	if r.pairMeAsap != nil {
		localVarFormParams.Add("pairMeAsap", parameterToString(*r.pairMeAsap, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiTournamentPostRequest struct {
	ctx                        context.Context
	ApiService                 *ArenaTournamentsApiService
	clockTime                  *interface{}
	clockIncrement             *interface{}
	minutes                    *interface{}
	name                       *interface{}
	waitMinutes                *interface{}
	startDate                  *interface{}
	variant                    *VariantKey
	rated                      *interface{}
	position                   *interface{}
	berserkable                *interface{}
	streakable                 *interface{}
	hasChat                    *interface{}
	description                *interface{}
	password                   *interface{}
	teamBattleByTeam           *interface{}
	conditionsTeamMemberTeamId *interface{}
	conditionsMinRatingRating  *interface{}
	conditionsMaxRatingRating  *interface{}
	conditionsNbRatedGameNb    *interface{}
	conditionsAllowList        *interface{}
}

// Clock initial time in minutes
func (r ApiApiTournamentPostRequest) ClockTime(clockTime interface{}) ApiApiTournamentPostRequest {
	r.clockTime = &clockTime
	return r
}

// Clock increment in seconds
func (r ApiApiTournamentPostRequest) ClockIncrement(clockIncrement interface{}) ApiApiTournamentPostRequest {
	r.clockIncrement = &clockIncrement
	return r
}

// How long the tournament lasts, in minutes
func (r ApiApiTournamentPostRequest) Minutes(minutes interface{}) ApiApiTournamentPostRequest {
	r.minutes = &minutes
	return r
}

// The tournament name. Leave empty to get a random Grandmaster name
func (r ApiApiTournamentPostRequest) Name(name interface{}) ApiApiTournamentPostRequest {
	r.name = &name
	return r
}

// How long to wait before starting the tournament, from now, in minutes
func (r ApiApiTournamentPostRequest) WaitMinutes(waitMinutes interface{}) ApiApiTournamentPostRequest {
	r.waitMinutes = &waitMinutes
	return r
}

// Timestamp (in milliseconds) to start the tournament at a given date and time. Overrides the &#x60;waitMinutes&#x60; setting
func (r ApiApiTournamentPostRequest) StartDate(startDate interface{}) ApiApiTournamentPostRequest {
	r.startDate = &startDate
	return r
}

func (r ApiApiTournamentPostRequest) Variant(variant VariantKey) ApiApiTournamentPostRequest {
	r.variant = &variant
	return r
}

// Games are rated and impact players ratings
func (r ApiApiTournamentPostRequest) Rated(rated interface{}) ApiApiTournamentPostRequest {
	r.rated = &rated
	return r
}

// Custom initial position (in FEN) for all games of the tournament. Must be a legal chess position. Only works with standard chess, not variants (except Chess960).
func (r ApiApiTournamentPostRequest) Position(position interface{}) ApiApiTournamentPostRequest {
	r.position = &position
	return r
}

// Whether the players can use berserk. Only allowed if clockIncrement &lt;&#x3D; clockTime * 2
func (r ApiApiTournamentPostRequest) Berserkable(berserkable interface{}) ApiApiTournamentPostRequest {
	r.berserkable = &berserkable
	return r
}

// After 2 wins, consecutive wins grant 4 points instead of 2.
func (r ApiApiTournamentPostRequest) Streakable(streakable interface{}) ApiApiTournamentPostRequest {
	r.streakable = &streakable
	return r
}

// Whether the players can discuss in a chat
func (r ApiApiTournamentPostRequest) HasChat(hasChat interface{}) ApiApiTournamentPostRequest {
	r.hasChat = &hasChat
	return r
}

// Anything you want to tell players about the tournament
func (r ApiApiTournamentPostRequest) Description(description interface{}) ApiApiTournamentPostRequest {
	r.description = &description
	return r
}

// Make the tournament private, and restrict access with a password. You can also [generate user-specific entry codes](https://github.com/lichess-org/api/tree/master/example/tournament-entry-code) based on this password.
func (r ApiApiTournamentPostRequest) Password(password interface{}) ApiApiTournamentPostRequest {
	r.password = &password
	return r
}

// Set the ID of a team you lead to create a team battle. The other teams can be added using the [team battle edit endpoint](#operation/apiTournamentTeamBattlePost).
func (r ApiApiTournamentPostRequest) TeamBattleByTeam(teamBattleByTeam interface{}) ApiApiTournamentPostRequest {
	r.teamBattleByTeam = &teamBattleByTeam
	return r
}

// Restrict entry to members of a team.  The teamId is the last part of a team URL, e.g. &#x60;https://lichess.org/team/coders&#x60; has teamId &#x3D; &#x60;coders&#x60;.  Leave empty to let everyone join the tournament.  Do not use this to create team battles, use &#x60;teamBattleByTeam&#x60; instead.
func (r ApiApiTournamentPostRequest) ConditionsTeamMemberTeamId(conditionsTeamMemberTeamId interface{}) ApiApiTournamentPostRequest {
	r.conditionsTeamMemberTeamId = &conditionsTeamMemberTeamId
	return r
}

// Minimum rating to join. Leave empty to let everyone join the tournament.
func (r ApiApiTournamentPostRequest) ConditionsMinRatingRating(conditionsMinRatingRating interface{}) ApiApiTournamentPostRequest {
	r.conditionsMinRatingRating = &conditionsMinRatingRating
	return r
}

// Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
func (r ApiApiTournamentPostRequest) ConditionsMaxRatingRating(conditionsMaxRatingRating interface{}) ApiApiTournamentPostRequest {
	r.conditionsMaxRatingRating = &conditionsMaxRatingRating
	return r
}

// Minimum number of rated games required to join.
func (r ApiApiTournamentPostRequest) ConditionsNbRatedGameNb(conditionsNbRatedGameNb interface{}) ApiApiTournamentPostRequest {
	r.conditionsNbRatedGameNb = &conditionsNbRatedGameNb
	return r
}

// Predefined list of usernames that are allowed to join, separated by commas. If this list is non-empty, then usernames absent from this list will be forbidden to join. Adding &#x60;%titled&#x60; to the list additionally allows any titled player to join. Example: &#x60;thibault,german11,%titled&#x60;
func (r ApiApiTournamentPostRequest) ConditionsAllowList(conditionsAllowList interface{}) ApiApiTournamentPostRequest {
	r.conditionsAllowList = &conditionsAllowList
	return r
}

func (r ApiApiTournamentPostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiTournamentPostExecute(r)
}

/*
ApiTournamentPost Create a new Arena tournament

Create a public or private Arena tournament.

This endpoint mirrors the form on <https://lichess.org/tournament/new>.

You can create up to 12 public tournaments per day, or 24 private tournaments.

A team battle can be created by specifying the `teambBattleByTeam` argument.

Additional restrictions:
  - clockTime + clockIncrement > 0
  - 15s and 0+1 variant tournaments cannot be rated
  - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiTournamentPostRequest
*/
func (a *ArenaTournamentsApiService) ApiTournamentPost(ctx context.Context) ApiApiTournamentPostRequest {
	return ApiApiTournamentPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ArenaTournamentsApiService) ApiTournamentPostExecute(r ApiApiTournamentPostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.ApiTournamentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clockTime == nil {
		return localVarReturnValue, nil, reportError("clockTime is required and must be specified")
	}
	if r.clockIncrement == nil {
		return localVarReturnValue, nil, reportError("clockIncrement is required and must be specified")
	}
	if r.minutes == nil {
		return localVarReturnValue, nil, reportError("minutes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.name != nil {
		localVarFormParams.Add("name", parameterToString(*r.name, ""))
	}
	localVarFormParams.Add("clockTime", parameterToString(*r.clockTime, ""))
	localVarFormParams.Add("clockIncrement", parameterToString(*r.clockIncrement, ""))
	localVarFormParams.Add("minutes", parameterToString(*r.minutes, ""))
	if r.waitMinutes != nil {
		localVarFormParams.Add("waitMinutes", parameterToString(*r.waitMinutes, ""))
	}
	if r.startDate != nil {
		localVarFormParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.variant != nil {
		localVarFormParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.rated != nil {
		localVarFormParams.Add("rated", parameterToString(*r.rated, ""))
	}
	if r.position != nil {
		localVarFormParams.Add("position", parameterToString(*r.position, ""))
	}
	if r.berserkable != nil {
		localVarFormParams.Add("berserkable", parameterToString(*r.berserkable, ""))
	}
	if r.streakable != nil {
		localVarFormParams.Add("streakable", parameterToString(*r.streakable, ""))
	}
	if r.hasChat != nil {
		localVarFormParams.Add("hasChat", parameterToString(*r.hasChat, ""))
	}
	if r.description != nil {
		localVarFormParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.password != nil {
		localVarFormParams.Add("password", parameterToString(*r.password, ""))
	}
	if r.teamBattleByTeam != nil {
		localVarFormParams.Add("teamBattleByTeam", parameterToString(*r.teamBattleByTeam, ""))
	}
	if r.conditionsTeamMemberTeamId != nil {
		localVarFormParams.Add("conditions.teamMember.teamId", parameterToString(*r.conditionsTeamMemberTeamId, ""))
	}
	if r.conditionsMinRatingRating != nil {
		localVarFormParams.Add("conditions.minRating.rating", parameterToString(*r.conditionsMinRatingRating, ""))
	}
	if r.conditionsMaxRatingRating != nil {
		localVarFormParams.Add("conditions.maxRating.rating", parameterToString(*r.conditionsMaxRatingRating, ""))
	}
	if r.conditionsNbRatedGameNb != nil {
		localVarFormParams.Add("conditions.nbRatedGame.nb", parameterToString(*r.conditionsNbRatedGameNb, ""))
	}
	if r.conditionsAllowList != nil {
		localVarFormParams.Add("conditions.allowList", parameterToString(*r.conditionsAllowList, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiTournamentTeamBattlePostRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
	id         interface{}
	teams      *interface{}
	nbLeaders  *interface{}
}

// All team IDs of the team battle, separated by commas. Make sure to always send the full list. Teams that are not in the list will be removed from the team battle.  Example: &#x60;coders,zhigalko_sergei-fan-club,hhSwTKZv&#x60;
func (r ApiApiTournamentTeamBattlePostRequest) Teams(teams interface{}) ApiApiTournamentTeamBattlePostRequest {
	r.teams = &teams
	return r
}

// Number team leaders per team.
func (r ApiApiTournamentTeamBattlePostRequest) NbLeaders(nbLeaders interface{}) ApiApiTournamentTeamBattlePostRequest {
	r.nbLeaders = &nbLeaders
	return r
}

func (r ApiApiTournamentTeamBattlePostRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiTournamentTeamBattlePostExecute(r)
}

/*
ApiTournamentTeamBattlePost Update a team battle

Set the teams and number of leaders of a team battle.

To update the other attributes of a team battle, use the [tournament update endpoint](#operation/apiTournamentUpdate).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID (8 characters)..
 @return ApiApiTournamentTeamBattlePostRequest
*/
func (a *ArenaTournamentsApiService) ApiTournamentTeamBattlePost(ctx context.Context, id interface{}) ApiApiTournamentTeamBattlePostRequest {
	return ApiApiTournamentTeamBattlePostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ArenaTournamentsApiService) ApiTournamentTeamBattlePostExecute(r ApiApiTournamentTeamBattlePostRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.ApiTournamentTeamBattlePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament/team-battle/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teams == nil {
		return localVarReturnValue, nil, reportError("teams is required and must be specified")
	}
	if r.nbLeaders == nil {
		return localVarReturnValue, nil, reportError("nbLeaders is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("teams", parameterToString(*r.teams, ""))
	localVarFormParams.Add("nbLeaders", parameterToString(*r.nbLeaders, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiTournamentTerminateRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
	id         interface{}
}

func (r ApiApiTournamentTerminateRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.ApiTournamentTerminateExecute(r)
}

/*
ApiTournamentTerminate Terminate an Arena tournament

Terminate an Arena tournament


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiApiTournamentTerminateRequest
*/
func (a *ArenaTournamentsApiService) ApiTournamentTerminate(ctx context.Context, id interface{}) ApiApiTournamentTerminateRequest {
	return ApiApiTournamentTerminateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return Ok
func (a *ArenaTournamentsApiService) ApiTournamentTerminateExecute(r ApiApiTournamentTerminateRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.ApiTournamentTerminate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament/{id}/terminate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiTournamentUpdateRequest struct {
	ctx                       context.Context
	ApiService                *ArenaTournamentsApiService
	id                        interface{}
	clockTime                 *interface{}
	clockIncrement            *interface{}
	minutes                   *interface{}
	name                      *interface{}
	waitMinutes               *interface{}
	startDate                 *interface{}
	variant                   *VariantKey
	rated                     *interface{}
	position                  *interface{}
	berserkable               *interface{}
	streakable                *interface{}
	hasChat                   *interface{}
	description               *interface{}
	password                  *interface{}
	conditionsMinRatingRating *interface{}
	conditionsMaxRatingRating *interface{}
	conditionsNbRatedGameNb   *interface{}
	conditionsAllowList       *interface{}
}

// Clock initial time in minutes
func (r ApiApiTournamentUpdateRequest) ClockTime(clockTime interface{}) ApiApiTournamentUpdateRequest {
	r.clockTime = &clockTime
	return r
}

// Clock increment in seconds
func (r ApiApiTournamentUpdateRequest) ClockIncrement(clockIncrement interface{}) ApiApiTournamentUpdateRequest {
	r.clockIncrement = &clockIncrement
	return r
}

// How long the tournament lasts, in minutes
func (r ApiApiTournamentUpdateRequest) Minutes(minutes interface{}) ApiApiTournamentUpdateRequest {
	r.minutes = &minutes
	return r
}

// The tournament name. Leave empty to get a random Grandmaster name
func (r ApiApiTournamentUpdateRequest) Name(name interface{}) ApiApiTournamentUpdateRequest {
	r.name = &name
	return r
}

// How long to wait before starting the tournament, from now, in minutes
func (r ApiApiTournamentUpdateRequest) WaitMinutes(waitMinutes interface{}) ApiApiTournamentUpdateRequest {
	r.waitMinutes = &waitMinutes
	return r
}

// Timestamp (in milliseconds) to start the tournament at a given date and time. Overrides the &#x60;waitMinutes&#x60; setting
func (r ApiApiTournamentUpdateRequest) StartDate(startDate interface{}) ApiApiTournamentUpdateRequest {
	r.startDate = &startDate
	return r
}

func (r ApiApiTournamentUpdateRequest) Variant(variant VariantKey) ApiApiTournamentUpdateRequest {
	r.variant = &variant
	return r
}

// Games are rated and impact players ratings
func (r ApiApiTournamentUpdateRequest) Rated(rated interface{}) ApiApiTournamentUpdateRequest {
	r.rated = &rated
	return r
}

// Custom initial position (in FEN) for all games of the tournament. Must be a legal chess position. Only works with standard chess, not variants (except Chess960).
func (r ApiApiTournamentUpdateRequest) Position(position interface{}) ApiApiTournamentUpdateRequest {
	r.position = &position
	return r
}

// Whether the players can use berserk. Only allowed if clockIncrement &lt;&#x3D; clockTime * 2
func (r ApiApiTournamentUpdateRequest) Berserkable(berserkable interface{}) ApiApiTournamentUpdateRequest {
	r.berserkable = &berserkable
	return r
}

// After 2 wins, consecutive wins grant 4 points instead of 2.
func (r ApiApiTournamentUpdateRequest) Streakable(streakable interface{}) ApiApiTournamentUpdateRequest {
	r.streakable = &streakable
	return r
}

// Whether the players can discuss in a chat
func (r ApiApiTournamentUpdateRequest) HasChat(hasChat interface{}) ApiApiTournamentUpdateRequest {
	r.hasChat = &hasChat
	return r
}

// Anything you want to tell players about the tournament
func (r ApiApiTournamentUpdateRequest) Description(description interface{}) ApiApiTournamentUpdateRequest {
	r.description = &description
	return r
}

// Make the tournament private, and restrict access with a password
func (r ApiApiTournamentUpdateRequest) Password(password interface{}) ApiApiTournamentUpdateRequest {
	r.password = &password
	return r
}

// Minimum rating to join. Leave empty to let everyone join the tournament.
func (r ApiApiTournamentUpdateRequest) ConditionsMinRatingRating(conditionsMinRatingRating interface{}) ApiApiTournamentUpdateRequest {
	r.conditionsMinRatingRating = &conditionsMinRatingRating
	return r
}

// Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
func (r ApiApiTournamentUpdateRequest) ConditionsMaxRatingRating(conditionsMaxRatingRating interface{}) ApiApiTournamentUpdateRequest {
	r.conditionsMaxRatingRating = &conditionsMaxRatingRating
	return r
}

// Minimum number of rated games required to join.
func (r ApiApiTournamentUpdateRequest) ConditionsNbRatedGameNb(conditionsNbRatedGameNb interface{}) ApiApiTournamentUpdateRequest {
	r.conditionsNbRatedGameNb = &conditionsNbRatedGameNb
	return r
}

// Predefined list of usernames that are allowed to join, separated by commas. If this list is non-empty, then usernames absent from this list will be forbidden to join. Adding &#x60;%titled&#x60; to the list additionally allows any titled player to join. Example: &#x60;thibault,german11,%titled&#x60;
func (r ApiApiTournamentUpdateRequest) ConditionsAllowList(conditionsAllowList interface{}) ApiApiTournamentUpdateRequest {
	r.conditionsAllowList = &conditionsAllowList
	return r
}

func (r ApiApiTournamentUpdateRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiTournamentUpdateExecute(r)
}

/*
ApiTournamentUpdate Update an Arena tournament

Update an Arena tournament.

Be mindful not to make important changes to ongoing tournaments.

Can be used to update a team battle.

Additional restrictions:
  - clockTime + clockIncrement > 0
  - 15s and 0+1 variant tournaments cannot be rated
  - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiApiTournamentUpdateRequest
*/
func (a *ArenaTournamentsApiService) ApiTournamentUpdate(ctx context.Context, id interface{}) ApiApiTournamentUpdateRequest {
	return ApiApiTournamentUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ArenaTournamentsApiService) ApiTournamentUpdateExecute(r ApiApiTournamentUpdateRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.ApiTournamentUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clockTime == nil {
		return localVarReturnValue, nil, reportError("clockTime is required and must be specified")
	}
	if r.clockIncrement == nil {
		return localVarReturnValue, nil, reportError("clockIncrement is required and must be specified")
	}
	if r.minutes == nil {
		return localVarReturnValue, nil, reportError("minutes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.name != nil {
		localVarFormParams.Add("name", parameterToString(*r.name, ""))
	}
	localVarFormParams.Add("clockTime", parameterToString(*r.clockTime, ""))
	localVarFormParams.Add("clockIncrement", parameterToString(*r.clockIncrement, ""))
	localVarFormParams.Add("minutes", parameterToString(*r.minutes, ""))
	if r.waitMinutes != nil {
		localVarFormParams.Add("waitMinutes", parameterToString(*r.waitMinutes, ""))
	}
	if r.startDate != nil {
		localVarFormParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.variant != nil {
		localVarFormParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.rated != nil {
		localVarFormParams.Add("rated", parameterToString(*r.rated, ""))
	}
	if r.position != nil {
		localVarFormParams.Add("position", parameterToString(*r.position, ""))
	}
	if r.berserkable != nil {
		localVarFormParams.Add("berserkable", parameterToString(*r.berserkable, ""))
	}
	if r.streakable != nil {
		localVarFormParams.Add("streakable", parameterToString(*r.streakable, ""))
	}
	if r.hasChat != nil {
		localVarFormParams.Add("hasChat", parameterToString(*r.hasChat, ""))
	}
	if r.description != nil {
		localVarFormParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.password != nil {
		localVarFormParams.Add("password", parameterToString(*r.password, ""))
	}
	if r.conditionsMinRatingRating != nil {
		localVarFormParams.Add("conditions.minRating.rating", parameterToString(*r.conditionsMinRatingRating, ""))
	}
	if r.conditionsMaxRatingRating != nil {
		localVarFormParams.Add("conditions.maxRating.rating", parameterToString(*r.conditionsMaxRatingRating, ""))
	}
	if r.conditionsNbRatedGameNb != nil {
		localVarFormParams.Add("conditions.nbRatedGame.nb", parameterToString(*r.conditionsNbRatedGameNb, ""))
	}
	if r.conditionsAllowList != nil {
		localVarFormParams.Add("conditions.allowList", parameterToString(*r.conditionsAllowList, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiTournamentWithdrawRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
	id         interface{}
}

func (r ApiApiTournamentWithdrawRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.ApiTournamentWithdrawExecute(r)
}

/*
ApiTournamentWithdraw Pause or leave an Arena tournament

Leave a future Arena tournament, or take a break on an ongoing Arena tournament.
It's possible to join again later. Points and streaks are preserved.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiApiTournamentWithdrawRequest
*/
func (a *ArenaTournamentsApiService) ApiTournamentWithdraw(ctx context.Context, id interface{}) ApiApiTournamentWithdrawRequest {
	return ApiApiTournamentWithdrawRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return Ok
func (a *ArenaTournamentsApiService) ApiTournamentWithdrawExecute(r ApiApiTournamentWithdrawRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.ApiTournamentWithdraw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament/{id}/withdraw"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiUserNameTournamentCreatedRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
	username   interface{}
	status     *interface{}
}

// Include tournaments in the given status: \&quot;Created\&quot; (10), \&quot;Started\&quot; (20), \&quot;Finished\&quot; (30)  You can add this parameter more than once to include tournaments in different statuses.   Example: &#x60;?status&#x3D;10&amp;status&#x3D;20&#x60;
func (r ApiApiUserNameTournamentCreatedRequest) Status(status interface{}) ApiApiUserNameTournamentCreatedRequest {
	r.status = &status
	return r
}

func (r ApiApiUserNameTournamentCreatedRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiUserNameTournamentCreatedExecute(r)
}

/*
ApiUserNameTournamentCreated Get tournaments created by a user

Get all tournaments created by a given user.

Tournaments are sorted by reverse chronological order of start date (last starting first).

Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The user whose created tournaments to fetch
 @return ApiApiUserNameTournamentCreatedRequest
*/
func (a *ArenaTournamentsApiService) ApiUserNameTournamentCreated(ctx context.Context, username interface{}) ApiApiUserNameTournamentCreatedRequest {
	return ApiApiUserNameTournamentCreatedRequest{
		ApiService: a,
		ctx:        ctx,
		username:   username,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ArenaTournamentsApiService) ApiUserNameTournamentCreatedExecute(r ApiApiUserNameTournamentCreatedRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.ApiUserNameTournamentCreated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/user/{username}/tournament/created"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGamesByTournamentRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
	id         interface{}
	player     *interface{}
	moves      *interface{}
	pgnInJson  *interface{}
	tags       *interface{}
	clocks     *interface{}
	evals      *interface{}
	opening    *interface{}
}

// Only games of a particular player. Leave empty to fetch games of all players.
func (r ApiGamesByTournamentRequest) Player(player interface{}) ApiGamesByTournamentRequest {
	r.player = &player
	return r
}

// Include the PGN moves.
func (r ApiGamesByTournamentRequest) Moves(moves interface{}) ApiGamesByTournamentRequest {
	r.moves = &moves
	return r
}

// Include the full PGN within the JSON response, in a &#x60;pgn&#x60; field.
func (r ApiGamesByTournamentRequest) PgnInJson(pgnInJson interface{}) ApiGamesByTournamentRequest {
	r.pgnInJson = &pgnInJson
	return r
}

// Include the PGN tags.
func (r ApiGamesByTournamentRequest) Tags(tags interface{}) ApiGamesByTournamentRequest {
	r.tags = &tags
	return r
}

// Include clock comments in the PGN moves, when available.  Example: &#x60;2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }&#x60;
func (r ApiGamesByTournamentRequest) Clocks(clocks interface{}) ApiGamesByTournamentRequest {
	r.clocks = &clocks
	return r
}

// Include analysis evaluation comments in the PGN, when available.  Example: &#x60;12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }&#x60;
func (r ApiGamesByTournamentRequest) Evals(evals interface{}) ApiGamesByTournamentRequest {
	r.evals = &evals
	return r
}

// Include the opening name.  Example: &#x60;[Opening \&quot;King&#39;s Gambit Accepted, King&#39;s Knight Gambit\&quot;]&#x60;
func (r ApiGamesByTournamentRequest) Opening(opening interface{}) ApiGamesByTournamentRequest {
	r.opening = &opening
	return r
}

func (r ApiGamesByTournamentRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GamesByTournamentExecute(r)
}

/*
GamesByTournament Export games of an Arena tournament

Download games of a tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.

Games are sorted by reverse chronological order (most recent first).

The game stream is throttled, depending on who is making the request:
  - Anonymous request: 20 games per second
  - [OAuth2 authenticated](#section/Authentication) request: 30 games per second


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiGamesByTournamentRequest
*/
func (a *ArenaTournamentsApiService) GamesByTournament(ctx context.Context, id interface{}) ApiGamesByTournamentRequest {
	return ApiGamesByTournamentRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ArenaTournamentsApiService) GamesByTournamentExecute(r ApiGamesByTournamentRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.GamesByTournament")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament/{id}/games"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.player != nil {
		localVarQueryParams.Add("player", parameterToString(*r.player, ""))
	}
	if r.moves != nil {
		localVarQueryParams.Add("moves", parameterToString(*r.moves, ""))
	}
	if r.pgnInJson != nil {
		localVarQueryParams.Add("pgnInJson", parameterToString(*r.pgnInJson, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	if r.clocks != nil {
		localVarQueryParams.Add("clocks", parameterToString(*r.clocks, ""))
	}
	if r.evals != nil {
		localVarQueryParams.Add("evals", parameterToString(*r.evals, ""))
	}
	if r.opening != nil {
		localVarQueryParams.Add("opening", parameterToString(*r.opening, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-chess-pgn", "application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResultsByTournamentRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
	id         interface{}
	nb         *interface{}
}

// Max number of players to fetch
func (r ApiResultsByTournamentRequest) Nb(nb interface{}) ApiResultsByTournamentRequest {
	r.nb = &nb
	return r
}

func (r ApiResultsByTournamentRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ResultsByTournamentExecute(r)
}

/*
ResultsByTournament Get results of an Arena tournament

Players of an Arena tournament, with their score and performance, sorted by rank (best first).

**Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON)**, i.e. one JSON object per line.

If called on an ongoing tournament, results can be inconsistent
due to ranking changes while the players are being streamed.
Use on finished tournaments for guaranteed consistency.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiResultsByTournamentRequest
*/
func (a *ArenaTournamentsApiService) ResultsByTournament(ctx context.Context, id interface{}) ApiResultsByTournamentRequest {
	return ApiResultsByTournamentRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ArenaTournamentsApiService) ResultsByTournamentExecute(r ApiResultsByTournamentRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.ResultsByTournament")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament/{id}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nb != nil {
		localVarQueryParams.Add("nb", parameterToString(*r.nb, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsByTournamentRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
	id         interface{}
}

func (r ApiTeamsByTournamentRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.TeamsByTournamentExecute(r)
}

/*
TeamsByTournament Get team standing of a team battle

Teams of a team battle tournament, with top players, sorted by rank (best first).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiTeamsByTournamentRequest
*/
func (a *ArenaTournamentsApiService) TeamsByTournament(ctx context.Context, id interface{}) ApiTeamsByTournamentRequest {
	return ApiTeamsByTournamentRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ArenaTournamentsApiService) TeamsByTournamentExecute(r ApiTeamsByTournamentRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.TeamsByTournament")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament/{id}/teams"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTournamentRequest struct {
	ctx        context.Context
	ApiService *ArenaTournamentsApiService
	id         interface{}
	page       *interface{}
}

// Specify which page of player standings to view.
func (r ApiTournamentRequest) Page(page interface{}) ApiTournamentRequest {
	r.page = &page
	return r
}

func (r ApiTournamentRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.TournamentExecute(r)
}

/*
Tournament Get info about an Arena tournament

Get detailed info about recently finished, current, or upcoming tournament's duels, player standings, and other info.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiTournamentRequest
*/
func (a *ArenaTournamentsApiService) Tournament(ctx context.Context, id interface{}) ApiTournamentRequest {
	return ApiTournamentRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ArenaTournamentsApiService) TournamentExecute(r ApiTournamentRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArenaTournamentsApiService.Tournament")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/tournament/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
