/*
Lichess.org API reference

# Introduction Welcome to the reference for the Lichess API! Lichess is free/libre, open-source chess server powered by volunteers and donations. - Get help in the [Lichess Discord channel](https://discord.gg/lichess) - API demo app with OAuth2 login, gameplay, and more: [source](https://github.com/lichess-org/api-demo) / [demo](https://lichess-org.github.io/api-demo/) - [Contribute to this documentation on Github](https://github.com/lichess-org/api) - Check out [Lichess widgets to embed in your website](https://lichess.org/developers) - [Download all Lichess rated games](https://database.lichess.org/) - [Download all Lichess puzzles with themes, ratings and votes](https://database.lichess.org/#puzzles)  ## Endpoint All requests go to `https://lichess.org` (unless otherwise specified).  ## Clients - [Python general API](https://github.com/ZackClements/berserk) - [MicroPython general API](https://github.com/mkomon/uberserk) - [Python general API - async](https://pypi.org/project/async-lichess-sdk) - [Python Lichess Bot](https://github.com/ShailChoksi/lichess-bot) - [Python Board API for Certabo](https://github.com/haklein/certabo-lichess) - [Java general API](https://github.com/tors42/chariot)  ## Rate limiting All requests are rate limited using various strategies, to ensure the API remains responsive for everyone. Only make one request at a time. If you receive an HTTP response with a [429 status](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429), please wait a full minute before resuming API usage.  ## Streaming with ND-JSON Some API endpoints stream their responses as [Newline Delimited JSON a.k.a. **nd-json**](http://ndjson.org/), with one JSON object per line.  Here's a [JavaScript utility function](https://gist.github.com/ornicar/a097406810939cf7be1df8ea30e94f3e) to help reading NDJSON streamed responses. 

API version: 2.0.0
Contact: contact@lichess.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// SwissTournamentsApiService SwissTournamentsApi service
type SwissTournamentsApiService service

type ApiApiSwissJoinRequest struct {
	ctx context.Context
	ApiService *SwissTournamentsApiService
	id interface{}
	password *interface{}
}

// The tournament password, if one is required
func (r ApiApiSwissJoinRequest) Password(password interface{}) ApiApiSwissJoinRequest {
	r.password = &password
	return r
}

func (r ApiApiSwissJoinRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.ApiSwissJoinExecute(r)
}

/*
ApiSwissJoin Join a Swiss tournament

Join a Swiss tournament, possibly with a password.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiApiSwissJoinRequest
*/
func (a *SwissTournamentsApiService) ApiSwissJoin(ctx context.Context, id interface{}) ApiApiSwissJoinRequest {
	return ApiApiSwissJoinRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Ok
func (a *SwissTournamentsApiService) ApiSwissJoinExecute(r ApiApiSwissJoinRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwissTournamentsApiService.ApiSwissJoin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/swiss/{id}/join"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.password != nil {
		localVarFormParams.Add("password", parameterToString(*r.password, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSwissNewRequest struct {
	ctx context.Context
	ApiService *SwissTournamentsApiService
	teamId interface{}
	clockLimit *interface{}
	clockIncrement *interface{}
	nbRounds *interface{}
	name *interface{}
	startsAt *interface{}
	roundInterval *interface{}
	variant *VariantKey
	description *interface{}
	rated *interface{}
	password *interface{}
	forbiddenPairings *interface{}
	manualPairings *interface{}
	chatFor *interface{}
	conditionsMinRatingRating *interface{}
	conditionsMaxRatingRating *interface{}
	conditionsNbRatedGameNb *interface{}
	conditionsAllowList *interface{}
}

// Clock initial time in seconds
func (r ApiApiSwissNewRequest) ClockLimit(clockLimit interface{}) ApiApiSwissNewRequest {
	r.clockLimit = &clockLimit
	return r
}

// Clock increment in seconds
func (r ApiApiSwissNewRequest) ClockIncrement(clockIncrement interface{}) ApiApiSwissNewRequest {
	r.clockIncrement = &clockIncrement
	return r
}

// Maximum number of rounds to play
func (r ApiApiSwissNewRequest) NbRounds(nbRounds interface{}) ApiApiSwissNewRequest {
	r.nbRounds = &nbRounds
	return r
}

// The tournament name. Leave empty to get a random Grandmaster name
func (r ApiApiSwissNewRequest) Name(name interface{}) ApiApiSwissNewRequest {
	r.name = &name
	return r
}

// Timestamp in milliseconds to start the tournament at a given date and time. By default, it starts 10 minutes after creation.
func (r ApiApiSwissNewRequest) StartsAt(startsAt interface{}) ApiApiSwissNewRequest {
	r.startsAt = &startsAt
	return r
}

// How long to wait between each round, in seconds.  Set to 99999999 to manually schedule each round from the tournament UI.  If empty or -1, a sensible value is picked automatically. 
func (r ApiApiSwissNewRequest) RoundInterval(roundInterval interface{}) ApiApiSwissNewRequest {
	r.roundInterval = &roundInterval
	return r
}

func (r ApiApiSwissNewRequest) Variant(variant VariantKey) ApiApiSwissNewRequest {
	r.variant = &variant
	return r
}

// Anything you want to tell players about the tournament
func (r ApiApiSwissNewRequest) Description(description interface{}) ApiApiSwissNewRequest {
	r.description = &description
	return r
}

// Games are rated and impact players ratings
func (r ApiApiSwissNewRequest) Rated(rated interface{}) ApiApiSwissNewRequest {
	r.rated = &rated
	return r
}

// Make the tournament private and restrict access with a password.
func (r ApiApiSwissNewRequest) Password(password interface{}) ApiApiSwissNewRequest {
	r.password = &password
	return r
}

// Usernames of players that must not play together.  Two usernames per line, separated by a space. 
func (r ApiApiSwissNewRequest) ForbiddenPairings(forbiddenPairings interface{}) ApiApiSwissNewRequest {
	r.forbiddenPairings = &forbiddenPairings
	return r
}

// Manual pairings for the next round.  Two usernames per line, separated by a space. Present players without a valid pairing will be given a bye, which is worth 1 point. Forfeited players will get 0 points. 
func (r ApiApiSwissNewRequest) ManualPairings(manualPairings interface{}) ApiApiSwissNewRequest {
	r.manualPairings = &manualPairings
	return r
}

// Who can read and write in the chat. - 0  &#x3D; No-one - 10 &#x3D; Only team leaders - 20 &#x3D; Only team members - 30 &#x3D; All Lichess players 
func (r ApiApiSwissNewRequest) ChatFor(chatFor interface{}) ApiApiSwissNewRequest {
	r.chatFor = &chatFor
	return r
}

// Minimum rating to join. Leave empty to let everyone join the tournament.
func (r ApiApiSwissNewRequest) ConditionsMinRatingRating(conditionsMinRatingRating interface{}) ApiApiSwissNewRequest {
	r.conditionsMinRatingRating = &conditionsMinRatingRating
	return r
}

// Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
func (r ApiApiSwissNewRequest) ConditionsMaxRatingRating(conditionsMaxRatingRating interface{}) ApiApiSwissNewRequest {
	r.conditionsMaxRatingRating = &conditionsMaxRatingRating
	return r
}

// Minimum number of rated games required to join.
func (r ApiApiSwissNewRequest) ConditionsNbRatedGameNb(conditionsNbRatedGameNb interface{}) ApiApiSwissNewRequest {
	r.conditionsNbRatedGameNb = &conditionsNbRatedGameNb
	return r
}

// Predefined list of usernames that are allowed to join, separated by commas. If this list is non-empty, then usernames absent from this list will be forbidden to join. Adding &#x60;%titled&#x60; to the list additionally allows any titled player to join. Example: &#x60;thibault,german11,%titled&#x60; 
func (r ApiApiSwissNewRequest) ConditionsAllowList(conditionsAllowList interface{}) ApiApiSwissNewRequest {
	r.conditionsAllowList = &conditionsAllowList
	return r
}

func (r ApiApiSwissNewRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiSwissNewExecute(r)
}

/*
ApiSwissNew Create a new Swiss tournament

Create a Swiss tournament for your team.

This endpoint mirrors the Swiss tournament form from your team pagee.

You can create up to 12 tournaments per day.

Additional restrictions:
  - clock.limit + clock.increment > 0
  - 15s and 0+1 variant tournaments cannot be rated


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId ID of the team
 @return ApiApiSwissNewRequest
*/
func (a *SwissTournamentsApiService) ApiSwissNew(ctx context.Context, teamId interface{}) ApiApiSwissNewRequest {
	return ApiApiSwissNewRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SwissTournamentsApiService) ApiSwissNewExecute(r ApiApiSwissNewRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwissTournamentsApiService.ApiSwissNew")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/swiss/new/{teamId}"
	localVarPath = strings.Replace(localVarPath, "{"+"teamId"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clockLimit == nil {
		return localVarReturnValue, nil, reportError("clockLimit is required and must be specified")
	}
	if r.clockIncrement == nil {
		return localVarReturnValue, nil, reportError("clockIncrement is required and must be specified")
	}
	if *r.clockIncrement < 0 {
		return localVarReturnValue, nil, reportError("clockIncrement must be greater than 0")
	}
	if *r.clockIncrement > 120 {
		return localVarReturnValue, nil, reportError("clockIncrement must be less than 120")
	}
	if r.nbRounds == nil {
		return localVarReturnValue, nil, reportError("nbRounds is required and must be specified")
	}
	if *r.nbRounds < 3 {
		return localVarReturnValue, nil, reportError("nbRounds must be greater than 3")
	}
	if *r.nbRounds > 100 {
		return localVarReturnValue, nil, reportError("nbRounds must be less than 100")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.name != nil {
		localVarFormParams.Add("name", parameterToString(*r.name, ""))
	}
	localVarFormParams.Add("clock.limit", parameterToString(*r.clockLimit, ""))
	localVarFormParams.Add("clock.increment", parameterToString(*r.clockIncrement, ""))
	localVarFormParams.Add("nbRounds", parameterToString(*r.nbRounds, ""))
	if r.startsAt != nil {
		localVarFormParams.Add("startsAt", parameterToString(*r.startsAt, ""))
	}
	if r.roundInterval != nil {
		localVarFormParams.Add("roundInterval", parameterToString(*r.roundInterval, ""))
	}
	if r.variant != nil {
		localVarFormParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.description != nil {
		localVarFormParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.rated != nil {
		localVarFormParams.Add("rated", parameterToString(*r.rated, ""))
	}
	if r.password != nil {
		localVarFormParams.Add("password", parameterToString(*r.password, ""))
	}
	if r.forbiddenPairings != nil {
		localVarFormParams.Add("forbiddenPairings", parameterToString(*r.forbiddenPairings, ""))
	}
	if r.manualPairings != nil {
		localVarFormParams.Add("manualPairings", parameterToString(*r.manualPairings, ""))
	}
	if r.chatFor != nil {
		localVarFormParams.Add("chatFor", parameterToString(*r.chatFor, ""))
	}
	if r.conditionsMinRatingRating != nil {
		localVarFormParams.Add("conditions.minRating.rating", parameterToString(*r.conditionsMinRatingRating, ""))
	}
	if r.conditionsMaxRatingRating != nil {
		localVarFormParams.Add("conditions.maxRating.rating", parameterToString(*r.conditionsMaxRatingRating, ""))
	}
	if r.conditionsNbRatedGameNb != nil {
		localVarFormParams.Add("conditions.nbRatedGame.nb", parameterToString(*r.conditionsNbRatedGameNb, ""))
	}
	if r.conditionsAllowList != nil {
		localVarFormParams.Add("conditions.allowList", parameterToString(*r.conditionsAllowList, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSwissTerminateRequest struct {
	ctx context.Context
	ApiService *SwissTournamentsApiService
	id interface{}
}

func (r ApiApiSwissTerminateRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.ApiSwissTerminateExecute(r)
}

/*
ApiSwissTerminate Terminate a Swiss tournament

Terminate a Swiss tournament


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The Swiss tournament ID.
 @return ApiApiSwissTerminateRequest
*/
func (a *SwissTournamentsApiService) ApiSwissTerminate(ctx context.Context, id interface{}) ApiApiSwissTerminateRequest {
	return ApiApiSwissTerminateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Ok
func (a *SwissTournamentsApiService) ApiSwissTerminateExecute(r ApiApiSwissTerminateRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwissTournamentsApiService.ApiSwissTerminate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/swiss/{id}/terminate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSwissUpdateRequest struct {
	ctx context.Context
	ApiService *SwissTournamentsApiService
	id interface{}
	clockLimit *interface{}
	clockIncrement *interface{}
	nbRounds *interface{}
	name *interface{}
	startsAt *interface{}
	roundInterval *interface{}
	variant *VariantKey
	description *interface{}
	rated *interface{}
	password *interface{}
	forbiddenPairings *interface{}
	manualPairings *interface{}
	chatFor *interface{}
	conditionsMinRatingRating *interface{}
	conditionsMaxRatingRating *interface{}
	conditionsNbRatedGameNb *interface{}
	conditionsAllowList *interface{}
}

// Clock initial time in seconds
func (r ApiApiSwissUpdateRequest) ClockLimit(clockLimit interface{}) ApiApiSwissUpdateRequest {
	r.clockLimit = &clockLimit
	return r
}

// Clock increment in seconds
func (r ApiApiSwissUpdateRequest) ClockIncrement(clockIncrement interface{}) ApiApiSwissUpdateRequest {
	r.clockIncrement = &clockIncrement
	return r
}

// Maximum number of rounds to play
func (r ApiApiSwissUpdateRequest) NbRounds(nbRounds interface{}) ApiApiSwissUpdateRequest {
	r.nbRounds = &nbRounds
	return r
}

// The tournament name. Leave empty to get a random Grandmaster name
func (r ApiApiSwissUpdateRequest) Name(name interface{}) ApiApiSwissUpdateRequest {
	r.name = &name
	return r
}

// Timestamp in milliseconds to start the tournament at a given date and time. By default, it starts 10 minutes after creation.
func (r ApiApiSwissUpdateRequest) StartsAt(startsAt interface{}) ApiApiSwissUpdateRequest {
	r.startsAt = &startsAt
	return r
}

// How long to wait between each round, in seconds.  Set to 99999999 to manually schedule each round from the tournament UI.  If empty or -1, a sensible value is picked automatically. 
func (r ApiApiSwissUpdateRequest) RoundInterval(roundInterval interface{}) ApiApiSwissUpdateRequest {
	r.roundInterval = &roundInterval
	return r
}

func (r ApiApiSwissUpdateRequest) Variant(variant VariantKey) ApiApiSwissUpdateRequest {
	r.variant = &variant
	return r
}

// Anything you want to tell players about the tournament
func (r ApiApiSwissUpdateRequest) Description(description interface{}) ApiApiSwissUpdateRequest {
	r.description = &description
	return r
}

// Games are rated and impact players ratings
func (r ApiApiSwissUpdateRequest) Rated(rated interface{}) ApiApiSwissUpdateRequest {
	r.rated = &rated
	return r
}

// Make the tournament private and restrict access with a password.
func (r ApiApiSwissUpdateRequest) Password(password interface{}) ApiApiSwissUpdateRequest {
	r.password = &password
	return r
}

// Usernames of players that must not play together.  Two usernames per line, separated by a space. 
func (r ApiApiSwissUpdateRequest) ForbiddenPairings(forbiddenPairings interface{}) ApiApiSwissUpdateRequest {
	r.forbiddenPairings = &forbiddenPairings
	return r
}

// Manual pairings for the next round.  Two usernames per line, separated by a space. Present players without a valid pairing will be given a bye, which is worth 1 point. Forfeited players will get 0 points. 
func (r ApiApiSwissUpdateRequest) ManualPairings(manualPairings interface{}) ApiApiSwissUpdateRequest {
	r.manualPairings = &manualPairings
	return r
}

// Who can read and write in the chat. - 0  &#x3D; No-one - 10 &#x3D; Only team leaders - 20 &#x3D; Only team members - 30 &#x3D; All Lichess players 
func (r ApiApiSwissUpdateRequest) ChatFor(chatFor interface{}) ApiApiSwissUpdateRequest {
	r.chatFor = &chatFor
	return r
}

// Minimum rating to join. Leave empty to let everyone join the tournament.
func (r ApiApiSwissUpdateRequest) ConditionsMinRatingRating(conditionsMinRatingRating interface{}) ApiApiSwissUpdateRequest {
	r.conditionsMinRatingRating = &conditionsMinRatingRating
	return r
}

// Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
func (r ApiApiSwissUpdateRequest) ConditionsMaxRatingRating(conditionsMaxRatingRating interface{}) ApiApiSwissUpdateRequest {
	r.conditionsMaxRatingRating = &conditionsMaxRatingRating
	return r
}

// Minimum number of rated games required to join.
func (r ApiApiSwissUpdateRequest) ConditionsNbRatedGameNb(conditionsNbRatedGameNb interface{}) ApiApiSwissUpdateRequest {
	r.conditionsNbRatedGameNb = &conditionsNbRatedGameNb
	return r
}

// Predefined list of usernames that are allowed to join, separated by commas. If this list is non-empty, then usernames absent from this list will be forbidden to join. Adding &#x60;%titled&#x60; to the list additionally allows any titled player to join. Example: &#x60;thibault,german11,%titled&#x60; 
func (r ApiApiSwissUpdateRequest) ConditionsAllowList(conditionsAllowList interface{}) ApiApiSwissUpdateRequest {
	r.conditionsAllowList = &conditionsAllowList
	return r
}

func (r ApiApiSwissUpdateRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiSwissUpdateExecute(r)
}

/*
ApiSwissUpdate Update a Swiss tournament.

Update a Swiss tournament.

Be mindful not to make important changes to ongoing tournaments.

Additional restrictions:
  - clock.limit + clock.increment > 0
  - 15s and 0+1 variant tournaments cannot be rated


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiApiSwissUpdateRequest
*/
func (a *SwissTournamentsApiService) ApiSwissUpdate(ctx context.Context, id interface{}) ApiApiSwissUpdateRequest {
	return ApiApiSwissUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SwissTournamentsApiService) ApiSwissUpdateExecute(r ApiApiSwissUpdateRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwissTournamentsApiService.ApiSwissUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/swiss/{id}/edit"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clockLimit == nil {
		return localVarReturnValue, nil, reportError("clockLimit is required and must be specified")
	}
	if r.clockIncrement == nil {
		return localVarReturnValue, nil, reportError("clockIncrement is required and must be specified")
	}
	if *r.clockIncrement < 0 {
		return localVarReturnValue, nil, reportError("clockIncrement must be greater than 0")
	}
	if *r.clockIncrement > 120 {
		return localVarReturnValue, nil, reportError("clockIncrement must be less than 120")
	}
	if r.nbRounds == nil {
		return localVarReturnValue, nil, reportError("nbRounds is required and must be specified")
	}
	if *r.nbRounds < 3 {
		return localVarReturnValue, nil, reportError("nbRounds must be greater than 3")
	}
	if *r.nbRounds > 100 {
		return localVarReturnValue, nil, reportError("nbRounds must be less than 100")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.name != nil {
		localVarFormParams.Add("name", parameterToString(*r.name, ""))
	}
	localVarFormParams.Add("clock.limit", parameterToString(*r.clockLimit, ""))
	localVarFormParams.Add("clock.increment", parameterToString(*r.clockIncrement, ""))
	localVarFormParams.Add("nbRounds", parameterToString(*r.nbRounds, ""))
	if r.startsAt != nil {
		localVarFormParams.Add("startsAt", parameterToString(*r.startsAt, ""))
	}
	if r.roundInterval != nil {
		localVarFormParams.Add("roundInterval", parameterToString(*r.roundInterval, ""))
	}
	if r.variant != nil {
		localVarFormParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.description != nil {
		localVarFormParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.rated != nil {
		localVarFormParams.Add("rated", parameterToString(*r.rated, ""))
	}
	if r.password != nil {
		localVarFormParams.Add("password", parameterToString(*r.password, ""))
	}
	if r.forbiddenPairings != nil {
		localVarFormParams.Add("forbiddenPairings", parameterToString(*r.forbiddenPairings, ""))
	}
	if r.manualPairings != nil {
		localVarFormParams.Add("manualPairings", parameterToString(*r.manualPairings, ""))
	}
	if r.chatFor != nil {
		localVarFormParams.Add("chatFor", parameterToString(*r.chatFor, ""))
	}
	if r.conditionsMinRatingRating != nil {
		localVarFormParams.Add("conditions.minRating.rating", parameterToString(*r.conditionsMinRatingRating, ""))
	}
	if r.conditionsMaxRatingRating != nil {
		localVarFormParams.Add("conditions.maxRating.rating", parameterToString(*r.conditionsMaxRatingRating, ""))
	}
	if r.conditionsNbRatedGameNb != nil {
		localVarFormParams.Add("conditions.nbRatedGame.nb", parameterToString(*r.conditionsNbRatedGameNb, ""))
	}
	if r.conditionsAllowList != nil {
		localVarFormParams.Add("conditions.allowList", parameterToString(*r.conditionsAllowList, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SwissUnauthorisedEdit
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSwissWithdrawRequest struct {
	ctx context.Context
	ApiService *SwissTournamentsApiService
	id interface{}
}

func (r ApiApiSwissWithdrawRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.ApiSwissWithdrawExecute(r)
}

/*
ApiSwissWithdraw Pause or leave a swiss tournament

Leave a future Swiss tournament, or take a break on an ongoing Swiss tournament.
It's possible to join again later. Points are preserved.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiApiSwissWithdrawRequest
*/
func (a *SwissTournamentsApiService) ApiSwissWithdraw(ctx context.Context, id interface{}) ApiApiSwissWithdrawRequest {
	return ApiApiSwissWithdrawRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Ok
func (a *SwissTournamentsApiService) ApiSwissWithdrawExecute(r ApiApiSwissWithdrawRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwissTournamentsApiService.ApiSwissWithdraw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/swiss/{id}/withdraw"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiTeamSwissRequest struct {
	ctx context.Context
	ApiService *SwissTournamentsApiService
	teamId interface{}
	max *interface{}
}

// How many tournaments to download.
func (r ApiApiTeamSwissRequest) Max(max interface{}) ApiApiTeamSwissRequest {
	r.max = &max
	return r
}

func (r ApiApiTeamSwissRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiTeamSwissExecute(r)
}

/*
ApiTeamSwiss Get team swiss tournaments

Get all swiss tournaments of a team.

Tournaments are sorted by reverse chronological order of start date (last starting first).

Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId
 @return ApiApiTeamSwissRequest
*/
func (a *SwissTournamentsApiService) ApiTeamSwiss(ctx context.Context, teamId interface{}) ApiApiTeamSwissRequest {
	return ApiApiTeamSwissRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SwissTournamentsApiService) ApiTeamSwissExecute(r ApiApiTeamSwissRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwissTournamentsApiService.ApiTeamSwiss")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/team/{teamId}/swiss"
	localVarPath = strings.Replace(localVarPath, "{"+"teamId"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		localVarQueryParams.Add("max", parameterToString(*r.max, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/nd-json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGamesBySwissRequest struct {
	ctx context.Context
	ApiService *SwissTournamentsApiService
	id interface{}
	moves *interface{}
	pgnInJson *interface{}
	tags *interface{}
	clocks *interface{}
	evals *interface{}
	opening *interface{}
}

// Include the PGN moves.
func (r ApiGamesBySwissRequest) Moves(moves interface{}) ApiGamesBySwissRequest {
	r.moves = &moves
	return r
}

// Include the full PGN within the JSON response, in a &#x60;pgn&#x60; field.
func (r ApiGamesBySwissRequest) PgnInJson(pgnInJson interface{}) ApiGamesBySwissRequest {
	r.pgnInJson = &pgnInJson
	return r
}

// Include the PGN tags.
func (r ApiGamesBySwissRequest) Tags(tags interface{}) ApiGamesBySwissRequest {
	r.tags = &tags
	return r
}

// Include clock comments in the PGN moves, when available.  Example: &#x60;2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }&#x60; 
func (r ApiGamesBySwissRequest) Clocks(clocks interface{}) ApiGamesBySwissRequest {
	r.clocks = &clocks
	return r
}

// Include analysis evaluation comments in the PGN, when available.  Example: &#x60;12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }&#x60; 
func (r ApiGamesBySwissRequest) Evals(evals interface{}) ApiGamesBySwissRequest {
	r.evals = &evals
	return r
}

// Include the opening name.  Example: &#x60;[Opening \&quot;King&#39;s Gambit Accepted, King&#39;s Knight Gambit\&quot;]&#x60; 
func (r ApiGamesBySwissRequest) Opening(opening interface{}) ApiGamesBySwissRequest {
	r.opening = &opening
	return r
}

func (r ApiGamesBySwissRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GamesBySwissExecute(r)
}

/*
GamesBySwiss Export games of a Swiss tournament

Download games of a swiss tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.

Games are sorted by reverse chronological order (last round first).

The game stream is throttled, depending on who is making the request:
  - Anonymous request: 20 games per second
  - [OAuth2 authenticated](#section/Authentication) request: 30 games per second


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiGamesBySwissRequest
*/
func (a *SwissTournamentsApiService) GamesBySwiss(ctx context.Context, id interface{}) ApiGamesBySwissRequest {
	return ApiGamesBySwissRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SwissTournamentsApiService) GamesBySwissExecute(r ApiGamesBySwissRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwissTournamentsApiService.GamesBySwiss")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/swiss/{id}/games"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.moves != nil {
		localVarQueryParams.Add("moves", parameterToString(*r.moves, ""))
	}
	if r.pgnInJson != nil {
		localVarQueryParams.Add("pgnInJson", parameterToString(*r.pgnInJson, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	if r.clocks != nil {
		localVarQueryParams.Add("clocks", parameterToString(*r.clocks, ""))
	}
	if r.evals != nil {
		localVarQueryParams.Add("evals", parameterToString(*r.evals, ""))
	}
	if r.opening != nil {
		localVarQueryParams.Add("opening", parameterToString(*r.opening, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-chess-pgn", "application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResultsBySwissRequest struct {
	ctx context.Context
	ApiService *SwissTournamentsApiService
	id interface{}
	nb *interface{}
}

// Max number of players to fetch
func (r ApiResultsBySwissRequest) Nb(nb interface{}) ApiResultsBySwissRequest {
	r.nb = &nb
	return r
}

func (r ApiResultsBySwissRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ResultsBySwissExecute(r)
}

/*
ResultsBySwiss Get results of a swiss tournament

Players of a swiss tournament, with their score and performance, sorted by rank (best first).

Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).

If called on an ongoing tournament, results can be inconsistent
due to ranking changes while the players are being streamed.
Use on finished tournaments for guaranteed consistency.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiResultsBySwissRequest
*/
func (a *SwissTournamentsApiService) ResultsBySwiss(ctx context.Context, id interface{}) ApiResultsBySwissRequest {
	return ApiResultsBySwissRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SwissTournamentsApiService) ResultsBySwissExecute(r ApiResultsBySwissRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwissTournamentsApiService.ResultsBySwiss")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/swiss/{id}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nb != nil {
		localVarQueryParams.Add("nb", parameterToString(*r.nb, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSwissRequest struct {
	ctx context.Context
	ApiService *SwissTournamentsApiService
	id interface{}
}

func (r ApiSwissRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.SwissExecute(r)
}

/*
Swiss Get info about a Swiss tournament

Get detailed info about a Swiss tournament.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The Swiss tournament ID.
 @return ApiSwissRequest
*/
func (a *SwissTournamentsApiService) Swiss(ctx context.Context, id interface{}) ApiSwissRequest {
	return ApiSwissRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SwissTournamentsApiService) SwissExecute(r ApiSwissRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwissTournamentsApiService.Swiss")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/swiss/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSwissTrfRequest struct {
	ctx context.Context
	ApiService *SwissTournamentsApiService
	id interface{}
}

func (r ApiSwissTrfRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.SwissTrfExecute(r)
}

/*
SwissTrf Export TRF of a Swiss tournament

Download a tournament in the Tournament Report File format, the FIDE standard.

Documentation: <https://www.fide.com/FIDE/handbook/C04Annex2_TRF16.pdf>

Example: <https://lichess.org/swiss/j8rtJ5GL.trf>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The tournament ID.
 @return ApiSwissTrfRequest
*/
func (a *SwissTournamentsApiService) SwissTrf(ctx context.Context, id interface{}) ApiSwissTrfRequest {
	return ApiSwissTrfRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SwissTournamentsApiService) SwissTrfExecute(r ApiSwissTrfRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwissTournamentsApiService.SwissTrf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swiss/{id}.trf"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
