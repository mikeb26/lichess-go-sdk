/*
Lichess.org API reference

# Introduction Welcome to the reference for the Lichess API! Lichess is free/libre, open-source chess server powered by volunteers and donations. - Get help in the [Lichess Discord channel](https://discord.gg/lichess) - API demo app with OAuth2 login, gameplay, and more: [source](https://github.com/lichess-org/api-demo) / [demo](https://lichess-org.github.io/api-demo/) - [Contribute to this documentation on Github](https://github.com/lichess-org/api) - Check out [Lichess widgets to embed in your website](https://lichess.org/developers) - [Download all Lichess rated games](https://database.lichess.org/) - [Download all Lichess puzzles with themes, ratings and votes](https://database.lichess.org/#puzzles)  ## Endpoint All requests go to `https://lichess.org` (unless otherwise specified).  ## Clients - [Python general API](https://github.com/ZackClements/berserk) - [MicroPython general API](https://github.com/mkomon/uberserk) - [Python general API - async](https://pypi.org/project/async-lichess-sdk) - [Python Lichess Bot](https://github.com/ShailChoksi/lichess-bot) - [Python Board API for Certabo](https://github.com/haklein/certabo-lichess) - [Java general API](https://github.com/tors42/chariot)  ## Rate limiting All requests are rate limited using various strategies, to ensure the API remains responsive for everyone. Only make one request at a time. If you receive an HTTP response with a [429 status](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429), please wait a full minute before resuming API usage.  ## Streaming with ND-JSON Some API endpoints stream their responses as [Newline Delimited JSON a.k.a. **nd-json**](http://ndjson.org/), with one JSON object per line.  Here's a [JavaScript utility function](https://gist.github.com/ornicar/a097406810939cf7be1df8ea30e94f3e) to help reading NDJSON streamed responses. 

API version: 2.0.0
Contact: contact@lichess.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// OpeningExplorerApiService OpeningExplorerApi service
type OpeningExplorerApiService service

type ApiOpeningExplorerLichessRequest struct {
	ctx context.Context
	ApiService *OpeningExplorerApiService
	variant *VariantKey
	fen *interface{}
	play *interface{}
	speeds *[]Speed
	ratings *[]interface{}
	since *interface{}
	until *interface{}
	moves *interface{}
	topGames *interface{}
	recentGames *interface{}
}

// Variant
func (r ApiOpeningExplorerLichessRequest) Variant(variant VariantKey) ApiOpeningExplorerLichessRequest {
	r.variant = &variant
	return r
}

// FEN of the root position
func (r ApiOpeningExplorerLichessRequest) Fen(fen interface{}) ApiOpeningExplorerLichessRequest {
	r.fen = &fen
	return r
}

// Comma separated sequence of legal moves in UCI notation. Play additional moves starting from &#x60;fen&#x60;. Required to find an opening name, if &#x60;fen&#x60; is not an exact match for a named position. 
func (r ApiOpeningExplorerLichessRequest) Play(play interface{}) ApiOpeningExplorerLichessRequest {
	r.play = &play
	return r
}

// Comma separated list of game speeds to look for
func (r ApiOpeningExplorerLichessRequest) Speeds(speeds []Speed) ApiOpeningExplorerLichessRequest {
	r.speeds = &speeds
	return r
}

// Comma separated list of rating groups, ranging from their value to the next higher group
func (r ApiOpeningExplorerLichessRequest) Ratings(ratings []interface{}) ApiOpeningExplorerLichessRequest {
	r.ratings = &ratings
	return r
}

// Include only games from this month or later
func (r ApiOpeningExplorerLichessRequest) Since(since interface{}) ApiOpeningExplorerLichessRequest {
	r.since = &since
	return r
}

// Include only games from this month or earlier
func (r ApiOpeningExplorerLichessRequest) Until(until interface{}) ApiOpeningExplorerLichessRequest {
	r.until = &until
	return r
}

// Number of most common moves to display
func (r ApiOpeningExplorerLichessRequest) Moves(moves interface{}) ApiOpeningExplorerLichessRequest {
	r.moves = &moves
	return r
}

// Number of top games to display
func (r ApiOpeningExplorerLichessRequest) TopGames(topGames interface{}) ApiOpeningExplorerLichessRequest {
	r.topGames = &topGames
	return r
}

// Number of recent games to display
func (r ApiOpeningExplorerLichessRequest) RecentGames(recentGames interface{}) ApiOpeningExplorerLichessRequest {
	r.recentGames = &recentGames
	return r
}

func (r ApiOpeningExplorerLichessRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.OpeningExplorerLichessExecute(r)
}

/*
OpeningExplorerLichess Lichess games

**Endpoint: <https://explorer.lichess.ovh/lichess>**

Games sampled from all Lichess players.

Example: `curl https://explorer.lichess.ovh/lichess?variant=standard&speeds=blitz,rapid,classical&ratings=2200,2500&fen=rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR%20w%20KQkq%20-%200%201`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOpeningExplorerLichessRequest
*/
func (a *OpeningExplorerApiService) OpeningExplorerLichess(ctx context.Context) ApiOpeningExplorerLichessRequest {
	return ApiOpeningExplorerLichessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OpeningExplorerApiService) OpeningExplorerLichessExecute(r ApiOpeningExplorerLichessRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpeningExplorerApiService.OpeningExplorerLichess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lichess"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.variant != nil {
		localVarQueryParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.fen != nil {
		localVarQueryParams.Add("fen", parameterToString(*r.fen, ""))
	}
	if r.play != nil {
		localVarQueryParams.Add("play", parameterToString(*r.play, ""))
	}
	if r.speeds != nil {
		t := *r.speeds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("speeds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("speeds", parameterToString(t, "multi"))
		}
	}
	if r.ratings != nil {
		t := *r.ratings
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ratings", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ratings", parameterToString(t, "multi"))
		}
	}
	if r.since != nil {
		localVarQueryParams.Add("since", parameterToString(*r.since, ""))
	}
	if r.until != nil {
		localVarQueryParams.Add("until", parameterToString(*r.until, ""))
	}
	if r.moves != nil {
		localVarQueryParams.Add("moves", parameterToString(*r.moves, ""))
	}
	if r.topGames != nil {
		localVarQueryParams.Add("topGames", parameterToString(*r.topGames, ""))
	}
	if r.recentGames != nil {
		localVarQueryParams.Add("recentGames", parameterToString(*r.recentGames, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpeningExplorerLichessHistoryRequest struct {
	ctx context.Context
	ApiService *OpeningExplorerApiService
	variant *VariantKey
	fen *interface{}
	play *interface{}
	speeds *interface{}
	ratings *interface{}
	since *interface{}
	until *interface{}
}

// Variant
func (r ApiOpeningExplorerLichessHistoryRequest) Variant(variant VariantKey) ApiOpeningExplorerLichessHistoryRequest {
	r.variant = &variant
	return r
}

// FEN of the root position
func (r ApiOpeningExplorerLichessHistoryRequest) Fen(fen interface{}) ApiOpeningExplorerLichessHistoryRequest {
	r.fen = &fen
	return r
}

// Comma separated sequence of legal moves in UCI notation. Play additional moves starting from &#x60;fen&#x60;. Required to find an opening name, if &#x60;fen&#x60; is not an exact match for a named position. 
func (r ApiOpeningExplorerLichessHistoryRequest) Play(play interface{}) ApiOpeningExplorerLichessHistoryRequest {
	r.play = &play
	return r
}

// Comma separated list of game speeds to look for
func (r ApiOpeningExplorerLichessHistoryRequest) Speeds(speeds interface{}) ApiOpeningExplorerLichessHistoryRequest {
	r.speeds = &speeds
	return r
}

// Comma separated list of rating groups, ranging from their value to the next higher group
func (r ApiOpeningExplorerLichessHistoryRequest) Ratings(ratings interface{}) ApiOpeningExplorerLichessHistoryRequest {
	r.ratings = &ratings
	return r
}

// Include only games from this month or later
func (r ApiOpeningExplorerLichessHistoryRequest) Since(since interface{}) ApiOpeningExplorerLichessHistoryRequest {
	r.since = &since
	return r
}

// Include only games from this month or earlier
func (r ApiOpeningExplorerLichessHistoryRequest) Until(until interface{}) ApiOpeningExplorerLichessHistoryRequest {
	r.until = &until
	return r
}

func (r ApiOpeningExplorerLichessHistoryRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.OpeningExplorerLichessHistoryExecute(r)
}

/*
OpeningExplorerLichessHistory Lichess games history

**Endpoint: <https://explorer.lichess.ovh/lichess/history>**

Opening statistics of games sampled from all Lichess players, grouped
by month. Starts with the first month that has any data,
or at `since` if given.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOpeningExplorerLichessHistoryRequest
*/
func (a *OpeningExplorerApiService) OpeningExplorerLichessHistory(ctx context.Context) ApiOpeningExplorerLichessHistoryRequest {
	return ApiOpeningExplorerLichessHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OpeningExplorerApiService) OpeningExplorerLichessHistoryExecute(r ApiOpeningExplorerLichessHistoryRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpeningExplorerApiService.OpeningExplorerLichessHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lichess/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.variant != nil {
		localVarQueryParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.fen != nil {
		localVarQueryParams.Add("fen", parameterToString(*r.fen, ""))
	}
	if r.play != nil {
		localVarQueryParams.Add("play", parameterToString(*r.play, ""))
	}
	if r.speeds != nil {
		localVarQueryParams.Add("speeds", parameterToString(*r.speeds, ""))
	}
	if r.ratings != nil {
		localVarQueryParams.Add("ratings", parameterToString(*r.ratings, ""))
	}
	if r.since != nil {
		localVarQueryParams.Add("since", parameterToString(*r.since, ""))
	}
	if r.until != nil {
		localVarQueryParams.Add("until", parameterToString(*r.until, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpeningExplorerMasterRequest struct {
	ctx context.Context
	ApiService *OpeningExplorerApiService
	fen *interface{}
	play *interface{}
	since *interface{}
	until *interface{}
	moves *interface{}
	topGames *interface{}
}

// FEN of the root position
func (r ApiOpeningExplorerMasterRequest) Fen(fen interface{}) ApiOpeningExplorerMasterRequest {
	r.fen = &fen
	return r
}

// Comma separated sequence of legal moves in UCI notation. Play additional moves starting from &#x60;fen&#x60;. Required to find an opening name, if &#x60;fen&#x60; is not an exact match for a named position. 
func (r ApiOpeningExplorerMasterRequest) Play(play interface{}) ApiOpeningExplorerMasterRequest {
	r.play = &play
	return r
}

// Include only games from this year or later
func (r ApiOpeningExplorerMasterRequest) Since(since interface{}) ApiOpeningExplorerMasterRequest {
	r.since = &since
	return r
}

// Include only games from this year or earlier
func (r ApiOpeningExplorerMasterRequest) Until(until interface{}) ApiOpeningExplorerMasterRequest {
	r.until = &until
	return r
}

// Number of most common moves to display
func (r ApiOpeningExplorerMasterRequest) Moves(moves interface{}) ApiOpeningExplorerMasterRequest {
	r.moves = &moves
	return r
}

// Number of top games to display
func (r ApiOpeningExplorerMasterRequest) TopGames(topGames interface{}) ApiOpeningExplorerMasterRequest {
	r.topGames = &topGames
	return r
}

func (r ApiOpeningExplorerMasterRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.OpeningExplorerMasterExecute(r)
}

/*
OpeningExplorerMaster Masters database

**Endpoint: <https://explorer.lichess.ovh/masters>**

Example: `curl https://explorer.lichess.ovh/masters?play=d2d4,d7d5,c2c4,c7c6,c4d5`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOpeningExplorerMasterRequest
*/
func (a *OpeningExplorerApiService) OpeningExplorerMaster(ctx context.Context) ApiOpeningExplorerMasterRequest {
	return ApiOpeningExplorerMasterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OpeningExplorerApiService) OpeningExplorerMasterExecute(r ApiOpeningExplorerMasterRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpeningExplorerApiService.OpeningExplorerMaster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/masters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fen != nil {
		localVarQueryParams.Add("fen", parameterToString(*r.fen, ""))
	}
	if r.play != nil {
		localVarQueryParams.Add("play", parameterToString(*r.play, ""))
	}
	if r.since != nil {
		localVarQueryParams.Add("since", parameterToString(*r.since, ""))
	}
	if r.until != nil {
		localVarQueryParams.Add("until", parameterToString(*r.until, ""))
	}
	if r.moves != nil {
		localVarQueryParams.Add("moves", parameterToString(*r.moves, ""))
	}
	if r.topGames != nil {
		localVarQueryParams.Add("topGames", parameterToString(*r.topGames, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpeningExplorerMasterGameRequest struct {
	ctx context.Context
	ApiService *OpeningExplorerApiService
	gameId interface{}
}

func (r ApiOpeningExplorerMasterGameRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.OpeningExplorerMasterGameExecute(r)
}

/*
OpeningExplorerMasterGame OTB master game

**Endpoint: `https://explorer.lichess.ovh/masters/pgn/{gameId}`**

Example: `curl https://explorer.lichess.ovh/masters/pgn/aAbqI4ey`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param gameId
 @return ApiOpeningExplorerMasterGameRequest
*/
func (a *OpeningExplorerApiService) OpeningExplorerMasterGame(ctx context.Context, gameId interface{}) ApiOpeningExplorerMasterGameRequest {
	return ApiOpeningExplorerMasterGameRequest{
		ApiService: a,
		ctx: ctx,
		gameId: gameId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OpeningExplorerApiService) OpeningExplorerMasterGameExecute(r ApiOpeningExplorerMasterGameRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpeningExplorerApiService.OpeningExplorerMasterGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/master/pgn/{gameId}"
	localVarPath = strings.Replace(localVarPath, "{"+"gameId"+"}", url.PathEscape(parameterToString(r.gameId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-chess-pgn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpeningExplorerPlayerRequest struct {
	ctx context.Context
	ApiService *OpeningExplorerApiService
	player *interface{}
	variant *VariantKey
	fen *interface{}
	play *interface{}
	speeds *interface{}
	modes *[]interface{}
	since *interface{}
	until *interface{}
	moves *interface{}
	recentGames *interface{}
}

// Username or ID of the player
func (r ApiOpeningExplorerPlayerRequest) Player(player interface{}) ApiOpeningExplorerPlayerRequest {
	r.player = &player
	return r
}

// Variant
func (r ApiOpeningExplorerPlayerRequest) Variant(variant VariantKey) ApiOpeningExplorerPlayerRequest {
	r.variant = &variant
	return r
}

// FEN of the root position
func (r ApiOpeningExplorerPlayerRequest) Fen(fen interface{}) ApiOpeningExplorerPlayerRequest {
	r.fen = &fen
	return r
}

// Comma separated sequence of legal moves in UCI notation. Play additional moves starting from &#x60;fen&#x60;. Required to find an opening name, if &#x60;fen&#x60; is not an exact match for a named position. 
func (r ApiOpeningExplorerPlayerRequest) Play(play interface{}) ApiOpeningExplorerPlayerRequest {
	r.play = &play
	return r
}

// Comma separated list of game speeds to look for
func (r ApiOpeningExplorerPlayerRequest) Speeds(speeds interface{}) ApiOpeningExplorerPlayerRequest {
	r.speeds = &speeds
	return r
}

// Comma separated list of modes
func (r ApiOpeningExplorerPlayerRequest) Modes(modes []interface{}) ApiOpeningExplorerPlayerRequest {
	r.modes = &modes
	return r
}

// Include only games from this month or later
func (r ApiOpeningExplorerPlayerRequest) Since(since interface{}) ApiOpeningExplorerPlayerRequest {
	r.since = &since
	return r
}

// Include only games from this month or earlier
func (r ApiOpeningExplorerPlayerRequest) Until(until interface{}) ApiOpeningExplorerPlayerRequest {
	r.until = &until
	return r
}

// Number of most common moves to display
func (r ApiOpeningExplorerPlayerRequest) Moves(moves interface{}) ApiOpeningExplorerPlayerRequest {
	r.moves = &moves
	return r
}

// Number of recent games to display
func (r ApiOpeningExplorerPlayerRequest) RecentGames(recentGames interface{}) ApiOpeningExplorerPlayerRequest {
	r.recentGames = &recentGames
	return r
}

func (r ApiOpeningExplorerPlayerRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.OpeningExplorerPlayerExecute(r)
}

/*
OpeningExplorerPlayer Player games

**Endpoint: <https://explorer.lichess.ovh/player>**

Games of a Lichess player.

Responds with a stream of [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON). Will start indexing
on demand, immediately respond with the current results, and stream
more updates until indexing is complete. The stream is throttled
and deduplicated. Empty lines may be sent to avoid timeouts.

Will index new games at most once per minute, and revisit previously
ongoing games at most once every day.

Example: `curl https://explorer.lichess.ovh/player?player=revoof&color=white&play=d2d4,d7d5&recentGames=1`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOpeningExplorerPlayerRequest
*/
func (a *OpeningExplorerApiService) OpeningExplorerPlayer(ctx context.Context) ApiOpeningExplorerPlayerRequest {
	return ApiOpeningExplorerPlayerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OpeningExplorerApiService) OpeningExplorerPlayerExecute(r ApiOpeningExplorerPlayerRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpeningExplorerApiService.OpeningExplorerPlayer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/player"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.player != nil {
		localVarQueryParams.Add("player", parameterToString(*r.player, ""))
	}
	if r.variant != nil {
		localVarQueryParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.fen != nil {
		localVarQueryParams.Add("fen", parameterToString(*r.fen, ""))
	}
	if r.play != nil {
		localVarQueryParams.Add("play", parameterToString(*r.play, ""))
	}
	if r.speeds != nil {
		localVarQueryParams.Add("speeds", parameterToString(*r.speeds, ""))
	}
	if r.modes != nil {
		t := *r.modes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("modes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("modes", parameterToString(t, "multi"))
		}
	}
	if r.since != nil {
		localVarQueryParams.Add("since", parameterToString(*r.since, ""))
	}
	if r.until != nil {
		localVarQueryParams.Add("until", parameterToString(*r.until, ""))
	}
	if r.moves != nil {
		localVarQueryParams.Add("moves", parameterToString(*r.moves, ""))
	}
	if r.recentGames != nil {
		localVarQueryParams.Add("recentGames", parameterToString(*r.recentGames, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/nd-json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
