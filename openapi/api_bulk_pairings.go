/*
Lichess.org API reference

# Introduction Welcome to the reference for the Lichess API! Lichess is free/libre, open-source chess server powered by volunteers and donations. - Get help in the [Lichess Discord channel](https://discord.gg/lichess) - API demo app with OAuth2 login, gameplay, and more: [source](https://github.com/lichess-org/api-demo) / [demo](https://lichess-org.github.io/api-demo/) - [Contribute to this documentation on Github](https://github.com/lichess-org/api) - Check out [Lichess widgets to embed in your website](https://lichess.org/developers) - [Download all Lichess rated games](https://database.lichess.org/) - [Download all Lichess puzzles with themes, ratings and votes](https://database.lichess.org/#puzzles)  ## Endpoint All requests go to `https://lichess.org` (unless otherwise specified).  ## Clients - [Python general API](https://github.com/ZackClements/berserk) - [MicroPython general API](https://github.com/mkomon/uberserk) - [Python general API - async](https://pypi.org/project/async-lichess-sdk) - [Python Lichess Bot](https://github.com/ShailChoksi/lichess-bot) - [Python Board API for Certabo](https://github.com/haklein/certabo-lichess) - [Java general API](https://github.com/tors42/chariot)  ## Rate limiting All requests are rate limited using various strategies, to ensure the API remains responsive for everyone. Only make one request at a time. If you receive an HTTP response with a [429 status](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429), please wait a full minute before resuming API usage.  ## Streaming with ND-JSON Some API endpoints stream their responses as [Newline Delimited JSON a.k.a. **nd-json**](http://ndjson.org/), with one JSON object per line.  Here's a [JavaScript utility function](https://gist.github.com/ornicar/a097406810939cf7be1df8ea30e94f3e) to help reading NDJSON streamed responses. 

API version: 2.0.0
Contact: contact@lichess.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// BulkPairingsApiService BulkPairingsApi service
type BulkPairingsApiService service

type ApiBulkPairingCreateRequest struct {
	ctx context.Context
	ApiService *BulkPairingsApiService
	players *interface{}
	clockLimit *interface{}
	clockIncrement *interface{}
	days *interface{}
	pairAt *interface{}
	startClocksAt *interface{}
	rated *interface{}
	variant *VariantKey
	fen *interface{}
	message *interface{}
	rules *interface{}
}

// OAuth tokens of all the players to pair, with the syntax &#x60;tokenOfWhitePlayerInGame1:tokenOfBlackPlayerInGame1,tokenOfWhitePlayerInGame2:tokenOfBlackPlayerInGame2,...&#x60;.  The 2 tokens of the players of a game are separated with &#x60;:&#x60;. The first token gets the white pieces. Games are separated with &#x60;,&#x60;.  Up to 1000 tokens can be sent, for a max of 500 games.  Each token must be included at most once.  Example: &#x60;token1:token2,token3:token4,token5:token6&#x60; 
func (r ApiBulkPairingCreateRequest) Players(players interface{}) ApiBulkPairingCreateRequest {
	r.players = &players
	return r
}

// Clock initial time in seconds. Example: &#x60;600&#x60; 
func (r ApiBulkPairingCreateRequest) ClockLimit(clockLimit interface{}) ApiBulkPairingCreateRequest {
	r.clockLimit = &clockLimit
	return r
}

// Clock increment in seconds. Example: &#x60;2&#x60; 
func (r ApiBulkPairingCreateRequest) ClockIncrement(clockIncrement interface{}) ApiBulkPairingCreateRequest {
	r.clockIncrement = &clockIncrement
	return r
}

// Days per turn. For correspondence games only.
func (r ApiBulkPairingCreateRequest) Days(days interface{}) ApiBulkPairingCreateRequest {
	r.days = &days
	return r
}

// Date at which the games will be created as a Unix timestamp in milliseconds. Up to 24h in the future. Omit, or set to current date and time, to start the games immediately. Example: &#x60;1612289869919&#x60; 
func (r ApiBulkPairingCreateRequest) PairAt(pairAt interface{}) ApiBulkPairingCreateRequest {
	r.pairAt = &pairAt
	return r
}

// Date at which the clocks will be automatically started as a Unix timestamp in milliseconds. Up to 24h in the future. Note that the clocks can start earlier than specified, if players start making moves in the game. If omitted, the clocks will not start automatically. Example: &#x60;1612289869919&#x60; 
func (r ApiBulkPairingCreateRequest) StartClocksAt(startClocksAt interface{}) ApiBulkPairingCreateRequest {
	r.startClocksAt = &startClocksAt
	return r
}

// Game is rated and impacts players ratings
func (r ApiBulkPairingCreateRequest) Rated(rated interface{}) ApiBulkPairingCreateRequest {
	r.rated = &rated
	return r
}

func (r ApiBulkPairingCreateRequest) Variant(variant VariantKey) ApiBulkPairingCreateRequest {
	r.variant = &variant
	return r
}

// Custom initial position (in FEN). Variant must be standard, fromPosition, or chess960 (if a valid 960 starting position), and the game cannot be rated.
func (r ApiBulkPairingCreateRequest) Fen(fen interface{}) ApiBulkPairingCreateRequest {
	r.fen = &fen
	return r
}

// Message that will be sent to each player, when the game is created.  It is sent from your user account.  &#x60;{opponent}&#x60; and &#x60;{game}&#x60; are placeholders that will be replaced with the opponent and the game URLs.  You can omit this field to send the default message, but if you set your own message, it must at least contain the &#x60;{game}&#x60; placeholder. 
func (r ApiBulkPairingCreateRequest) Message(message interface{}) ApiBulkPairingCreateRequest {
	r.message = &message
	return r
}

// Extra game rules separated by commas. Example: &#x60;noAbort,noRematch&#x60; 
func (r ApiBulkPairingCreateRequest) Rules(rules interface{}) ApiBulkPairingCreateRequest {
	r.rules = &rules
	return r
}

func (r ApiBulkPairingCreateRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.BulkPairingCreateExecute(r)
}

/*
BulkPairingCreate Create a bulk pairing

Schedule many games at once, up to 24h in advance.

OAuth tokens are required for all paired players, with the `challenge:write` scope.

You can schedule up to 500 games every 10 minutes. [Contact us](mailto:contact@lichess.org) if you need higher limits.

If games have a real-time clock, each player must have only one pairing.
For correspondence games, players can have multiple pairings within the same bulk.

The entire bulk is rejected if:
  - a token is missing
  - a token is present more than once (except in correspondence)
  - a token lacks the `challenge:write` scope
  - a player account is closed
  - a player is paired more than once (except in correspondence)
  - a bulk is already scheduled to start at the same time with the same player
  - you have 10 scheduled bulks
  - you have 1000 scheduled games

Partial bulks are never created. Either it all fails, or it all succeeds.
When it fails, it does so with an error message explaining the issue.
Failed bulks are not counted in the rate limiting, they are free.
Fix the issues, manually or programmatically, then retry to schedule the bulk.

A successful bulk creation returns a JSON bulk document. Its ID can be used for further operations.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkPairingCreateRequest
*/
func (a *BulkPairingsApiService) BulkPairingCreate(ctx context.Context) ApiBulkPairingCreateRequest {
	return ApiBulkPairingCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *BulkPairingsApiService) BulkPairingCreateExecute(r ApiBulkPairingCreateRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkPairingsApiService.BulkPairingCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/bulk-pairing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.players != nil {
		localVarFormParams.Add("players", parameterToString(*r.players, ""))
	}
	if r.clockLimit != nil {
		localVarFormParams.Add("clock.limit", parameterToString(*r.clockLimit, ""))
	}
	if r.clockIncrement != nil {
		localVarFormParams.Add("clock.increment", parameterToString(*r.clockIncrement, ""))
	}
	if r.days != nil {
		localVarFormParams.Add("days", parameterToString(*r.days, ""))
	}
	if r.pairAt != nil {
		localVarFormParams.Add("pairAt", parameterToString(*r.pairAt, ""))
	}
	if r.startClocksAt != nil {
		localVarFormParams.Add("startClocksAt", parameterToString(*r.startClocksAt, ""))
	}
	if r.rated != nil {
		localVarFormParams.Add("rated", parameterToString(*r.rated, ""))
	}
	if r.variant != nil {
		localVarFormParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.fen != nil {
		localVarFormParams.Add("fen", parameterToString(*r.fen, ""))
	}
	if r.message != nil {
		localVarFormParams.Add("message", parameterToString(*r.message, ""))
	}
	if r.rules != nil {
		localVarFormParams.Add("rules", parameterToString(*r.rules, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkPairingDeleteRequest struct {
	ctx context.Context
	ApiService *BulkPairingsApiService
	id interface{}
}

func (r ApiBulkPairingDeleteRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.BulkPairingDeleteExecute(r)
}

/*
BulkPairingDelete Cancel a bulk pairing

Cancel and delete a bulk pairing that is scheduled in the future.

If the games have already been created, then this does nothing.

Canceling a bulk pairing does not refund the rate limit cost of that bulk pairing.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiBulkPairingDeleteRequest
*/
func (a *BulkPairingsApiService) BulkPairingDelete(ctx context.Context, id interface{}) ApiBulkPairingDeleteRequest {
	return ApiBulkPairingDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Ok
func (a *BulkPairingsApiService) BulkPairingDeleteExecute(r ApiBulkPairingDeleteRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkPairingsApiService.BulkPairingDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/bulk-pairing/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkPairingGetRequest struct {
	ctx context.Context
	ApiService *BulkPairingsApiService
}

func (r ApiBulkPairingGetRequest) Execute() ([]interface{}, *http.Response, error) {
	return r.ApiService.BulkPairingGetExecute(r)
}

/*
BulkPairingGet View upcoming bulk pairings

Get a list of upcoming bulk pairings you created.

Only bulk pairings that are scheduled in the future, or that have a clock start scheduled in the future, are listed.

Bulk pairings are deleted from the server after the pairings are done and the clocks have started.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkPairingGetRequest
*/
func (a *BulkPairingsApiService) BulkPairingGet(ctx context.Context) ApiBulkPairingGetRequest {
	return ApiBulkPairingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []interface{}
func (a *BulkPairingsApiService) BulkPairingGetExecute(r ApiBulkPairingGetRequest) ([]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkPairingsApiService.BulkPairingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/bulk-pairing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkPairingStartClocksRequest struct {
	ctx context.Context
	ApiService *BulkPairingsApiService
	id interface{}
}

func (r ApiBulkPairingStartClocksRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.BulkPairingStartClocksExecute(r)
}

/*
BulkPairingStartClocks Manually start clocks

Immediately start all clocks of the games of a bulk pairing.

This overrides the `startClocksAt` value of an existing bulk pairing.

If the games have not yet been created (`bulk.pairAt` is in the future), then this does nothing.

If the clocks have already started (`bulk.startClocksAt` is in the past), then this does nothing.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiBulkPairingStartClocksRequest
*/
func (a *BulkPairingsApiService) BulkPairingStartClocks(ctx context.Context, id interface{}) ApiBulkPairingStartClocksRequest {
	return ApiBulkPairingStartClocksRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Ok
func (a *BulkPairingsApiService) BulkPairingStartClocksExecute(r ApiBulkPairingStartClocksRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkPairingsApiService.BulkPairingStartClocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/bulk-pairing/{id}/start-clocks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
