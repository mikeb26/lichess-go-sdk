/*
Lichess.org API reference

# Introduction Welcome to the reference for the Lichess API! Lichess is free/libre, open-source chess server powered by volunteers and donations. - Get help in the [Lichess Discord channel](https://discord.gg/lichess) - API demo app with OAuth2 login, gameplay, and more: [source](https://github.com/lichess-org/api-demo) / [demo](https://lichess-org.github.io/api-demo/) - [Contribute to this documentation on Github](https://github.com/lichess-org/api) - Check out [Lichess widgets to embed in your website](https://lichess.org/developers) - [Download all Lichess rated games](https://database.lichess.org/) - [Download all Lichess puzzles with themes, ratings and votes](https://database.lichess.org/#puzzles)  ## Endpoint All requests go to `https://lichess.org` (unless otherwise specified).  ## Clients - [Python general API](https://github.com/ZackClements/berserk) - [MicroPython general API](https://github.com/mkomon/uberserk) - [Python general API - async](https://pypi.org/project/async-lichess-sdk) - [Python Lichess Bot](https://github.com/ShailChoksi/lichess-bot) - [Python Board API for Certabo](https://github.com/haklein/certabo-lichess) - [Java general API](https://github.com/tors42/chariot)  ## Rate limiting All requests are rate limited using various strategies, to ensure the API remains responsive for everyone. Only make one request at a time. If you receive an HTTP response with a [429 status](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429), please wait a full minute before resuming API usage.  ## Streaming with ND-JSON Some API endpoints stream their responses as [Newline Delimited JSON a.k.a. **nd-json**](http://ndjson.org/), with one JSON object per line.  Here's a [JavaScript utility function](https://gist.github.com/ornicar/a097406810939cf7be1df8ea30e94f3e) to help reading NDJSON streamed responses.

API version: 2.0.0
Contact: contact@lichess.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// ChallengesApiService ChallengesApi service
type ChallengesApiService service

type ApiAdminChallengeTokensRequest struct {
	ctx         context.Context
	ApiService  *ChallengesApiService
	users       *interface{}
	description *interface{}
}

// Usernames separated with commas
func (r ApiAdminChallengeTokensRequest) Users(users interface{}) ApiAdminChallengeTokensRequest {
	r.users = &users
	return r
}

// User visible description of the token
func (r ApiAdminChallengeTokensRequest) Description(description interface{}) ApiAdminChallengeTokensRequest {
	r.description = &description
	return r
}

func (r ApiAdminChallengeTokensRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminChallengeTokensExecute(r)
}

/*
AdminChallengeTokens Admin challenge tokens

**This endpoint can only be used by Lichess administrators. It will not work if you do not have the appropriate permissions.** Tournament organizers should instead use [OAuth](#tag/OAuth) to obtain `challenge:write` tokens from users in order to perform bulk pairing.*

Create and obtain `challenge:write` tokens for multiple users.

If a similar token already exists for a user, it is reused. This endpoint is idempotent.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdminChallengeTokensRequest
*/
func (a *ChallengesApiService) AdminChallengeTokens(ctx context.Context) ApiAdminChallengeTokensRequest {
	return ApiAdminChallengeTokensRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChallengesApiService) AdminChallengeTokensExecute(r ApiAdminChallengeTokensRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChallengesApiService.AdminChallengeTokens")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/token/admin-challenge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.users == nil {
		return nil, reportError("users is required and must be specified")
	}
	if r.description == nil {
		return nil, reportError("description is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("users", parameterToString(*r.users, ""))
	localVarFormParams.Add("description", parameterToString(*r.description, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChallengeAcceptRequest struct {
	ctx         context.Context
	ApiService  *ChallengesApiService
	challengeId interface{}
}

func (r ApiChallengeAcceptRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.ChallengeAcceptExecute(r)
}

/*
ChallengeAccept Accept a challenge

Accept an incoming challenge.

You should receive a `gameStart` event on the [incoming events stream](#operation/apiStreamEvent).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param challengeId
 @return ApiChallengeAcceptRequest
*/
func (a *ChallengesApiService) ChallengeAccept(ctx context.Context, challengeId interface{}) ApiChallengeAcceptRequest {
	return ApiChallengeAcceptRequest{
		ApiService:  a,
		ctx:         ctx,
		challengeId: challengeId,
	}
}

// Execute executes the request
//  @return Ok
func (a *ChallengesApiService) ChallengeAcceptExecute(r ApiChallengeAcceptRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChallengesApiService.ChallengeAccept")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/challenge/{challengeId}/accept"
	localVarPath = strings.Replace(localVarPath, "{"+"challengeId"+"}", url.PathEscape(parameterToString(r.challengeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChallengeAiRequest struct {
	ctx            context.Context
	ApiService     *ChallengesApiService
	level          *interface{}
	clockLimit     *interface{}
	clockIncrement *interface{}
	days           *interface{}
	color          *interface{}
	variant        *VariantKey
	fen            *interface{}
}

// AI strength
func (r ApiChallengeAiRequest) Level(level interface{}) ApiChallengeAiRequest {
	r.level = &level
	return r
}

// Clock initial time in seconds. If empty, a correspondence game is created.
func (r ApiChallengeAiRequest) ClockLimit(clockLimit interface{}) ApiChallengeAiRequest {
	r.clockLimit = &clockLimit
	return r
}

// Clock increment in seconds. If empty, a correspondence game is created.
func (r ApiChallengeAiRequest) ClockIncrement(clockIncrement interface{}) ApiChallengeAiRequest {
	r.clockIncrement = &clockIncrement
	return r
}

// Days per move, for correspondence games. Clock settings must be omitted.
func (r ApiChallengeAiRequest) Days(days interface{}) ApiChallengeAiRequest {
	r.days = &days
	return r
}

// Which color you get to play
func (r ApiChallengeAiRequest) Color(color interface{}) ApiChallengeAiRequest {
	r.color = &color
	return r
}

func (r ApiChallengeAiRequest) Variant(variant VariantKey) ApiChallengeAiRequest {
	r.variant = &variant
	return r
}

// Custom initial position (in FEN). Variant must be standard, fromPosition, or chess960 (if a valid 960 starting position), and the game cannot be rated.
func (r ApiChallengeAiRequest) Fen(fen interface{}) ApiChallengeAiRequest {
	r.fen = &fen
	return r
}

func (r ApiChallengeAiRequest) Execute() (*GameJson, *http.Response, error) {
	return r.ApiService.ChallengeAiExecute(r)
}

/*
ChallengeAi Challenge the AI

Start a game with Lichess AI.

You will be notified on the [event stream](#operation/apiStreamEvent) that a new game has started.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChallengeAiRequest
*/
func (a *ChallengesApiService) ChallengeAi(ctx context.Context) ApiChallengeAiRequest {
	return ApiChallengeAiRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GameJson
func (a *ChallengesApiService) ChallengeAiExecute(r ApiChallengeAiRequest) (*GameJson, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GameJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChallengesApiService.ChallengeAi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/challenge/ai"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.level != nil {
		localVarFormParams.Add("level", parameterToString(*r.level, ""))
	}
	if r.clockLimit != nil {
		localVarFormParams.Add("clock.limit", parameterToString(*r.clockLimit, ""))
	}
	if r.clockIncrement != nil {
		localVarFormParams.Add("clock.increment", parameterToString(*r.clockIncrement, ""))
	}
	if r.days != nil {
		localVarFormParams.Add("days", parameterToString(*r.days, ""))
	}
	if r.color != nil {
		localVarFormParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.variant != nil {
		localVarFormParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.fen != nil {
		localVarFormParams.Add("fen", parameterToString(*r.fen, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChallengeCancelRequest struct {
	ctx           context.Context
	ApiService    *ChallengesApiService
	challengeId   interface{}
	opponentToken *interface{}
}

// Optional &#x60;challenge:write&#x60; token of the opponent. If set, the game can be canceled even if both players have moved.
func (r ApiChallengeCancelRequest) OpponentToken(opponentToken interface{}) ApiChallengeCancelRequest {
	r.opponentToken = &opponentToken
	return r
}

func (r ApiChallengeCancelRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.ChallengeCancelExecute(r)
}

/*
ChallengeCancel Cancel a challenge

Cancel a challenge you sent, or aborts the game if the challenge was accepted, but the game was not yet played.
Note that the ID of a game is the same as the ID of the challenge that created it.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param challengeId
 @return ApiChallengeCancelRequest
*/
func (a *ChallengesApiService) ChallengeCancel(ctx context.Context, challengeId interface{}) ApiChallengeCancelRequest {
	return ApiChallengeCancelRequest{
		ApiService:  a,
		ctx:         ctx,
		challengeId: challengeId,
	}
}

// Execute executes the request
//  @return Ok
func (a *ChallengesApiService) ChallengeCancelExecute(r ApiChallengeCancelRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChallengesApiService.ChallengeCancel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/challenge/{challengeId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"challengeId"+"}", url.PathEscape(parameterToString(r.challengeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.opponentToken != nil {
		localVarQueryParams.Add("opponentToken", parameterToString(*r.opponentToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChallengeCreateRequest struct {
	ctx             context.Context
	ApiService      *ChallengesApiService
	username        interface{}
	rated           *interface{}
	clockLimit      *interface{}
	clockIncrement  *interface{}
	days            *interface{}
	color           *interface{}
	variant         *VariantKey
	fen             *interface{}
	keepAliveStream *interface{}
	acceptByToken   *interface{}
	message         *interface{}
	rules           *interface{}
}

// Game is rated and impacts players ratings
func (r ApiChallengeCreateRequest) Rated(rated interface{}) ApiChallengeCreateRequest {
	r.rated = &rated
	return r
}

// Clock initial time in seconds. If empty, a correspondence game is created.
func (r ApiChallengeCreateRequest) ClockLimit(clockLimit interface{}) ApiChallengeCreateRequest {
	r.clockLimit = &clockLimit
	return r
}

// Clock increment in seconds. If empty, a correspondence game is created.
func (r ApiChallengeCreateRequest) ClockIncrement(clockIncrement interface{}) ApiChallengeCreateRequest {
	r.clockIncrement = &clockIncrement
	return r
}

// Days per move, for correspondence games. Clock settings must be omitted.
func (r ApiChallengeCreateRequest) Days(days interface{}) ApiChallengeCreateRequest {
	r.days = &days
	return r
}

// Which color you get to play
func (r ApiChallengeCreateRequest) Color(color interface{}) ApiChallengeCreateRequest {
	r.color = &color
	return r
}

func (r ApiChallengeCreateRequest) Variant(variant VariantKey) ApiChallengeCreateRequest {
	r.variant = &variant
	return r
}

// Custom initial position (in FEN). Variant must be standard, fromPosition, or chess960 (if a valid 960 starting position), and the game cannot be rated. Castling moves will use UCI_Chess960 notation, for example e1h1 instead of e1g1.
func (r ApiChallengeCreateRequest) Fen(fen interface{}) ApiChallengeCreateRequest {
	r.fen = &fen
	return r
}

// If set, the response is streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON). The challenge is kept alive until the connection is closed by the client. When the challenge is accepted, declined or canceled, a message of the form &#x60;{\\\&quot;done\\\&quot;:\\\&quot;accepted\\\&quot;}&#x60; is sent, then the connection is closed by the server. If not set, the response is not streamed, and the challenge expires after 20s if not accepted.
func (r ApiChallengeCreateRequest) KeepAliveStream(keepAliveStream interface{}) ApiChallengeCreateRequest {
	r.keepAliveStream = &keepAliveStream
	return r
}

// Immediately accept the challenge and create the game. Pass in an OAuth token (with the &#x60;challenge:write&#x60; scope) for the receiving user. On success, the response will contain a &#x60;game&#x60; field instead of a &#x60;challenge&#x60; field.  Alternatively, consider the [bulk pairing API](#operation/bulkPairingCreate).
func (r ApiChallengeCreateRequest) AcceptByToken(acceptByToken interface{}) ApiChallengeCreateRequest {
	r.acceptByToken = &acceptByToken
	return r
}

// **Only if &#x60;acceptByToken&#x60; is set.**  Message that is sent to each player, when the game is created. It is sent from your user account.  &#x60;{opponent}&#x60;, &#x60;{player}&#x60; and &#x60;{game}&#x60; are placeholders that will be replaced with the opponent name, player name, and the game URLs.  You can omit this field to send the default message, but if you set your own message, it must at least contain the &#x60;{game}&#x60; placeholder.
func (r ApiChallengeCreateRequest) Message(message interface{}) ApiChallengeCreateRequest {
	r.message = &message
	return r
}

// Extra game rules separated by commas. Example: &#x60;noAbort,noRematch&#x60;
func (r ApiChallengeCreateRequest) Rules(rules interface{}) ApiChallengeCreateRequest {
	r.rules = &rules
	return r
}

func (r ApiChallengeCreateRequest) Execute() (*ChallengeJson, *http.Response, error) {
	return r.ApiService.ChallengeCreateExecute(r)
}

/*
ChallengeCreate Create a challenge

Challenge someone to play. The targeted player can choose to accept or decline.

If the challenge is accepted, you will be notified on the [event stream](#operation/apiStreamEvent)
that a new game has started. The game ID will be the same as the challenge ID.

If you also have an OAuth token with `challenge:write` scope for the receiving user,
you can make them accept the challenge immediately by setting the `acceptByToken` field.

Challenges for realtime games (not correspondence) expire after 20s if not accepted.
To prevent that, use the `keepAliveStream` flag described below.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return ApiChallengeCreateRequest
*/
func (a *ChallengesApiService) ChallengeCreate(ctx context.Context, username interface{}) ApiChallengeCreateRequest {
	return ApiChallengeCreateRequest{
		ApiService: a,
		ctx:        ctx,
		username:   username,
	}
}

// Execute executes the request
//  @return ChallengeJson
func (a *ChallengesApiService) ChallengeCreateExecute(r ApiChallengeCreateRequest) (*ChallengeJson, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChallengeJson
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChallengesApiService.ChallengeCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/challenge/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.rated != nil {
		localVarFormParams.Add("rated", parameterToString(*r.rated, ""))
	}
	if r.clockLimit != nil {
		localVarFormParams.Add("clock.limit", parameterToString(*r.clockLimit, ""))
	}
	if r.clockIncrement != nil {
		localVarFormParams.Add("clock.increment", parameterToString(*r.clockIncrement, ""))
	}
	if r.days != nil {
		localVarFormParams.Add("days", parameterToString(*r.days, ""))
	}
	if r.color != nil {
		localVarFormParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.variant != nil {
		localVarFormParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.fen != nil {
		localVarFormParams.Add("fen", parameterToString(*r.fen, ""))
	}
	if r.keepAliveStream != nil {
		localVarFormParams.Add("keepAliveStream", parameterToString(*r.keepAliveStream, ""))
	}
	if r.acceptByToken != nil {
		localVarFormParams.Add("acceptByToken", parameterToString(*r.acceptByToken, ""))
	}
	if r.message != nil {
		localVarFormParams.Add("message", parameterToString(*r.message, ""))
	}
	if r.rules != nil {
		localVarFormParams.Add("rules", parameterToString(*r.rules, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChallengeDeclineRequest struct {
	ctx         context.Context
	ApiService  *ChallengesApiService
	challengeId interface{}
	reason      *interface{}
}

// Reason challenge was declined. It will be translated to the player&#39;s language. See [the full list in the translation file](https://github.com/ornicar/lila/blob/master/translation/source/challenge.xml#L14).
func (r ApiChallengeDeclineRequest) Reason(reason interface{}) ApiChallengeDeclineRequest {
	r.reason = &reason
	return r
}

func (r ApiChallengeDeclineRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.ChallengeDeclineExecute(r)
}

/*
ChallengeDecline Decline a challenge

Decline an incoming challenge.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param challengeId
 @return ApiChallengeDeclineRequest
*/
func (a *ChallengesApiService) ChallengeDecline(ctx context.Context, challengeId interface{}) ApiChallengeDeclineRequest {
	return ApiChallengeDeclineRequest{
		ApiService:  a,
		ctx:         ctx,
		challengeId: challengeId,
	}
}

// Execute executes the request
//  @return Ok
func (a *ChallengesApiService) ChallengeDeclineExecute(r ApiChallengeDeclineRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChallengesApiService.ChallengeDecline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/challenge/{challengeId}/decline"
	localVarPath = strings.Replace(localVarPath, "{"+"challengeId"+"}", url.PathEscape(parameterToString(r.challengeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.reason != nil {
		localVarFormParams.Add("reason", parameterToString(*r.reason, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChallengeListRequest struct {
	ctx        context.Context
	ApiService *ChallengesApiService
}

func (r ApiChallengeListRequest) Execute() (*ChallengeList200Response, *http.Response, error) {
	return r.ApiService.ChallengeListExecute(r)
}

/*
ChallengeList List your challenges

Get a list of challenges created by or targeted at you.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChallengeListRequest
*/
func (a *ChallengesApiService) ChallengeList(ctx context.Context) ApiChallengeListRequest {
	return ApiChallengeListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ChallengeList200Response
func (a *ChallengesApiService) ChallengeListExecute(r ApiChallengeListRequest) (*ChallengeList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChallengeList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChallengesApiService.ChallengeList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/challenge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChallengeOpenRequest struct {
	ctx            context.Context
	ApiService     *ChallengesApiService
	rated          *interface{}
	clockLimit     *interface{}
	clockIncrement *interface{}
	days           *interface{}
	variant        *VariantKey
	fen            *interface{}
	name           *interface{}
	rules          *interface{}
	users          *interface{}
}

// Game is rated and impacts players ratings
func (r ApiChallengeOpenRequest) Rated(rated interface{}) ApiChallengeOpenRequest {
	r.rated = &rated
	return r
}

// Clock initial time in seconds. If empty, a correspondence game is created.
func (r ApiChallengeOpenRequest) ClockLimit(clockLimit interface{}) ApiChallengeOpenRequest {
	r.clockLimit = &clockLimit
	return r
}

// Clock increment in seconds. If empty, a correspondence game is created.
func (r ApiChallengeOpenRequest) ClockIncrement(clockIncrement interface{}) ApiChallengeOpenRequest {
	r.clockIncrement = &clockIncrement
	return r
}

// Days per turn. For correspondence challenges.
func (r ApiChallengeOpenRequest) Days(days interface{}) ApiChallengeOpenRequest {
	r.days = &days
	return r
}

func (r ApiChallengeOpenRequest) Variant(variant VariantKey) ApiChallengeOpenRequest {
	r.variant = &variant
	return r
}

// Custom initial position (in FEN). Variant must be standard, fromPosition, or chess960 (if a valid 960 starting position), and the game cannot be rated.
func (r ApiChallengeOpenRequest) Fen(fen interface{}) ApiChallengeOpenRequest {
	r.fen = &fen
	return r
}

// Optional name for the challenge, that players will see on the challenge page.
func (r ApiChallengeOpenRequest) Name(name interface{}) ApiChallengeOpenRequest {
	r.name = &name
	return r
}

// Extra game rules separated by commas. Example: &#x60;noAbort,noRematch&#x60;
func (r ApiChallengeOpenRequest) Rules(rules interface{}) ApiChallengeOpenRequest {
	r.rules = &rules
	return r
}

// Optional pair of usernames, separated by a comma. If set, only these users will be allowed to join the game. The first username gets the white pieces. Example: &#x60;Username1,Username2&#x60;
func (r ApiChallengeOpenRequest) Users(users interface{}) ApiChallengeOpenRequest {
	r.users = &users
	return r
}

func (r ApiChallengeOpenRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ChallengeOpenExecute(r)
}

/*
ChallengeOpen Open-ended challenge

Create a challenge that any 2 players can join.

Share the URL of the challenge. the first 2 players to click it will be paired for a game.

The response body also contains `whiteUrl` and `blackUrl`.
You can control which color each player gets by giving them these URLs,
instead of the main challenge URL.

Open challenges expire after 24h.

To directly pair 2 known players, use [this endpoint](#operation/challengeCreate) instead,
with the `acceptByToken` parameter.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChallengeOpenRequest
*/
func (a *ChallengesApiService) ChallengeOpen(ctx context.Context) ApiChallengeOpenRequest {
	return ApiChallengeOpenRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *ChallengesApiService) ChallengeOpenExecute(r ApiChallengeOpenRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChallengesApiService.ChallengeOpen")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/challenge/open"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.rated != nil {
		localVarFormParams.Add("rated", parameterToString(*r.rated, ""))
	}
	if r.clockLimit != nil {
		localVarFormParams.Add("clock.limit", parameterToString(*r.clockLimit, ""))
	}
	if r.clockIncrement != nil {
		localVarFormParams.Add("clock.increment", parameterToString(*r.clockIncrement, ""))
	}
	if r.days != nil {
		localVarFormParams.Add("days", parameterToString(*r.days, ""))
	}
	if r.variant != nil {
		localVarFormParams.Add("variant", parameterToString(*r.variant, ""))
	}
	if r.fen != nil {
		localVarFormParams.Add("fen", parameterToString(*r.fen, ""))
	}
	if r.name != nil {
		localVarFormParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.rules != nil {
		localVarFormParams.Add("rules", parameterToString(*r.rules, ""))
	}
	if r.users != nil {
		localVarFormParams.Add("users", parameterToString(*r.users, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChallengeStartClocksRequest struct {
	ctx        context.Context
	ApiService *ChallengesApiService
	gameId     interface{}
	token1     *interface{}
	token2     *interface{}
}

// OAuth token of a player
func (r ApiChallengeStartClocksRequest) Token1(token1 interface{}) ApiChallengeStartClocksRequest {
	r.token1 = &token1
	return r
}

// OAuth token of the other player
func (r ApiChallengeStartClocksRequest) Token2(token2 interface{}) ApiChallengeStartClocksRequest {
	r.token2 = &token2
	return r
}

func (r ApiChallengeStartClocksRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.ChallengeStartClocksExecute(r)
}

/*
ChallengeStartClocks Start clocks of a game

Start the clocks of a game immediately, even if a player has not yet made a move.

Requires the OAuth tokens of both players with `challenge:write` scope.

If the clocks have already started, the call will have no effect.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param gameId
 @return ApiChallengeStartClocksRequest
*/
func (a *ChallengesApiService) ChallengeStartClocks(ctx context.Context, gameId interface{}) ApiChallengeStartClocksRequest {
	return ApiChallengeStartClocksRequest{
		ApiService: a,
		ctx:        ctx,
		gameId:     gameId,
	}
}

// Execute executes the request
//  @return Ok
func (a *ChallengesApiService) ChallengeStartClocksExecute(r ApiChallengeStartClocksRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChallengesApiService.ChallengeStartClocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/challenge/{gameId}/start-clocks"
	localVarPath = strings.Replace(localVarPath, "{"+"gameId"+"}", url.PathEscape(parameterToString(r.gameId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token1 != nil {
		localVarQueryParams.Add("token1", parameterToString(*r.token1, ""))
	}
	if r.token2 != nil {
		localVarQueryParams.Add("token2", parameterToString(*r.token2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRoundAddTimeRequest struct {
	ctx        context.Context
	ApiService *ChallengesApiService
	gameId     interface{}
	seconds    interface{}
}

func (r ApiRoundAddTimeRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.RoundAddTimeExecute(r)
}

/*
RoundAddTime Add time to the opponent clock

Add seconds to the opponent's clock. Can be used to create games with time odds.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param gameId
 @param seconds How many seconds to give
 @return ApiRoundAddTimeRequest
*/
func (a *ChallengesApiService) RoundAddTime(ctx context.Context, gameId interface{}, seconds interface{}) ApiRoundAddTimeRequest {
	return ApiRoundAddTimeRequest{
		ApiService: a,
		ctx:        ctx,
		gameId:     gameId,
		seconds:    seconds,
	}
}

// Execute executes the request
//  @return Ok
func (a *ChallengesApiService) RoundAddTimeExecute(r ApiRoundAddTimeRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChallengesApiService.RoundAddTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/round/{gameId}/add-time/{seconds}"
	localVarPath = strings.Replace(localVarPath, "{"+"gameId"+"}", url.PathEscape(parameterToString(r.gameId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seconds"+"}", url.PathEscape(parameterToString(r.seconds, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
