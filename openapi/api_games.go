/*
Lichess.org API reference

# Introduction Welcome to the reference for the Lichess API! Lichess is free/libre, open-source chess server powered by volunteers and donations. - Get help in the [Lichess Discord channel](https://discord.gg/lichess) - API demo app with OAuth2 login, gameplay, and more: [source](https://github.com/lichess-org/api-demo) / [demo](https://lichess-org.github.io/api-demo/) - [Contribute to this documentation on Github](https://github.com/lichess-org/api) - Check out [Lichess widgets to embed in your website](https://lichess.org/developers) - [Download all Lichess rated games](https://database.lichess.org/) - [Download all Lichess puzzles with themes, ratings and votes](https://database.lichess.org/#puzzles)  ## Endpoint All requests go to `https://lichess.org` (unless otherwise specified).  ## Clients - [Python general API](https://github.com/ZackClements/berserk) - [MicroPython general API](https://github.com/mkomon/uberserk) - [Python general API - async](https://pypi.org/project/async-lichess-sdk) - [Python Lichess Bot](https://github.com/ShailChoksi/lichess-bot) - [Python Board API for Certabo](https://github.com/haklein/certabo-lichess) - [Java general API](https://github.com/tors42/chariot)  ## Rate limiting All requests are rate limited using various strategies, to ensure the API remains responsive for everyone. Only make one request at a time. If you receive an HTTP response with a [429 status](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429), please wait a full minute before resuming API usage.  ## Streaming with ND-JSON Some API endpoints stream their responses as [Newline Delimited JSON a.k.a. **nd-json**](http://ndjson.org/), with one JSON object per line.  Here's a [JavaScript utility function](https://gist.github.com/ornicar/a097406810939cf7be1df8ea30e94f3e) to help reading NDJSON streamed responses. 

API version: 2.0.0
Contact: contact@lichess.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// GamesApiService GamesApi service
type GamesApiService service

type ApiApiAccountPlayingRequest struct {
	ctx context.Context
	ApiService *GamesApiService
	nb *interface{}
}

// Max number of games to fetch
func (r ApiApiAccountPlayingRequest) Nb(nb interface{}) ApiApiAccountPlayingRequest {
	r.nb = &nb
	return r
}

func (r ApiApiAccountPlayingRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiAccountPlayingExecute(r)
}

/*
ApiAccountPlaying Get my ongoing games

Get the ongoing games of the current user.
Real-time and correspondence games are included.
The most urgent games are listed first.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiAccountPlayingRequest
*/
func (a *GamesApiService) ApiAccountPlaying(ctx context.Context) ApiApiAccountPlayingRequest {
	return ApiApiAccountPlayingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *GamesApiService) ApiAccountPlayingExecute(r ApiApiAccountPlayingRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GamesApiService.ApiAccountPlaying")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/account/playing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nb != nil {
		localVarQueryParams.Add("nb", parameterToString(*r.nb, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiGamesUserRequest struct {
	ctx context.Context
	ApiService *GamesApiService
	username interface{}
	since *interface{}
	until *interface{}
	max *interface{}
	vs *interface{}
	rated *interface{}
	perfType *interface{}
	color *interface{}
	analysed *interface{}
	moves *interface{}
	pgnInJson *interface{}
	tags *interface{}
	clocks *interface{}
	evals *interface{}
	opening *interface{}
	ongoing *interface{}
	finished *interface{}
	literate *interface{}
	players *interface{}
	sort *interface{}
}

// Download games played since this timestamp. Defaults to account creation date.
func (r ApiApiGamesUserRequest) Since(since interface{}) ApiApiGamesUserRequest {
	r.since = &since
	return r
}

// Download games played until this timestamp. Defaults to now.
func (r ApiApiGamesUserRequest) Until(until interface{}) ApiApiGamesUserRequest {
	r.until = &until
	return r
}

// How many games to download. Leave empty to download all games.
func (r ApiApiGamesUserRequest) Max(max interface{}) ApiApiGamesUserRequest {
	r.max = &max
	return r
}

// [Filter] Only games played against this opponent
func (r ApiApiGamesUserRequest) Vs(vs interface{}) ApiApiGamesUserRequest {
	r.vs = &vs
	return r
}

// [Filter] Only rated (&#x60;true&#x60;) or casual (&#x60;false&#x60;) games
func (r ApiApiGamesUserRequest) Rated(rated interface{}) ApiApiGamesUserRequest {
	r.rated = &rated
	return r
}

// [Filter] Only games in these speeds or variants.   Multiple perf types can be specified, separated by a comma.   Example: blitz,rapid,classical
func (r ApiApiGamesUserRequest) PerfType(perfType interface{}) ApiApiGamesUserRequest {
	r.perfType = &perfType
	return r
}

// [Filter] Only games played as this color.
func (r ApiApiGamesUserRequest) Color(color interface{}) ApiApiGamesUserRequest {
	r.color = &color
	return r
}

// [Filter] Only games with or without a computer analysis available
func (r ApiApiGamesUserRequest) Analysed(analysed interface{}) ApiApiGamesUserRequest {
	r.analysed = &analysed
	return r
}

// Include the PGN moves.
func (r ApiApiGamesUserRequest) Moves(moves interface{}) ApiApiGamesUserRequest {
	r.moves = &moves
	return r
}

// Include the full PGN within the JSON response, in a &#x60;pgn&#x60; field. The response type must be set to &#x60;application/x-ndjson&#x60; by the request &#x60;Accept&#x60; header.
func (r ApiApiGamesUserRequest) PgnInJson(pgnInJson interface{}) ApiApiGamesUserRequest {
	r.pgnInJson = &pgnInJson
	return r
}

// Include the PGN tags.
func (r ApiApiGamesUserRequest) Tags(tags interface{}) ApiApiGamesUserRequest {
	r.tags = &tags
	return r
}

// Include clock comments in the PGN moves, when available.  Example: &#x60;2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }&#x60; 
func (r ApiApiGamesUserRequest) Clocks(clocks interface{}) ApiApiGamesUserRequest {
	r.clocks = &clocks
	return r
}

// Include analysis evaluation comments in the PGN, when available.  Example: &#x60;12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }&#x60; 
func (r ApiApiGamesUserRequest) Evals(evals interface{}) ApiApiGamesUserRequest {
	r.evals = &evals
	return r
}

// Include the opening name.  Example: &#x60;[Opening \&quot;King&#39;s Gambit Accepted, King&#39;s Knight Gambit\&quot;]&#x60; 
func (r ApiApiGamesUserRequest) Opening(opening interface{}) ApiApiGamesUserRequest {
	r.opening = &opening
	return r
}

// Include ongoing games. The last 3 moves will be omitted.
func (r ApiApiGamesUserRequest) Ongoing(ongoing interface{}) ApiApiGamesUserRequest {
	r.ongoing = &ongoing
	return r
}

// Include finished games. Set to &#x60;false&#x60; to only get ongoing games.
func (r ApiApiGamesUserRequest) Finished(finished interface{}) ApiApiGamesUserRequest {
	r.finished = &finished
	return r
}

// Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.  Example: &#x60;5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)&#x60; 
func (r ApiApiGamesUserRequest) Literate(literate interface{}) ApiApiGamesUserRequest {
	r.literate = &literate
	return r
}

// URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN. Example: &lt;https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt&gt; 
func (r ApiApiGamesUserRequest) Players(players interface{}) ApiApiGamesUserRequest {
	r.players = &players
	return r
}

// Sort order of the games.
func (r ApiApiGamesUserRequest) Sort(sort interface{}) ApiApiGamesUserRequest {
	r.sort = &sort
	return r
}

func (r ApiApiGamesUserRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiGamesUserExecute(r)
}

/*
ApiGamesUser Export games of a user

Download all games of any user in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.

Games are sorted by reverse chronological order (most recent first).

We recommend streaming the response, for it can be very long.
<https://lichess.org/@/german11> for instance has more than 500,000 games.

The game stream is throttled, depending on who is making the request:
  - Anonymous request: 20 games per second
  - [OAuth2 authenticated](#section/Authentication) request: 30 games per second
  - Authenticated, downloading your own games: 60 games per second


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The user name.
 @return ApiApiGamesUserRequest
*/
func (a *GamesApiService) ApiGamesUser(ctx context.Context, username interface{}) ApiApiGamesUserRequest {
	return ApiApiGamesUserRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return interface{}
func (a *GamesApiService) ApiGamesUserExecute(r ApiApiGamesUserRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GamesApiService.ApiGamesUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/games/user/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.since != nil {
		localVarQueryParams.Add("since", parameterToString(*r.since, ""))
	}
	if r.until != nil {
		localVarQueryParams.Add("until", parameterToString(*r.until, ""))
	}
	if r.max != nil {
		localVarQueryParams.Add("max", parameterToString(*r.max, ""))
	}
	if r.vs != nil {
		localVarQueryParams.Add("vs", parameterToString(*r.vs, ""))
	}
	if r.rated != nil {
		localVarQueryParams.Add("rated", parameterToString(*r.rated, ""))
	}
	if r.perfType != nil {
		localVarQueryParams.Add("perfType", parameterToString(*r.perfType, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.analysed != nil {
		localVarQueryParams.Add("analysed", parameterToString(*r.analysed, ""))
	}
	if r.moves != nil {
		localVarQueryParams.Add("moves", parameterToString(*r.moves, ""))
	}
	if r.pgnInJson != nil {
		localVarQueryParams.Add("pgnInJson", parameterToString(*r.pgnInJson, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	if r.clocks != nil {
		localVarQueryParams.Add("clocks", parameterToString(*r.clocks, ""))
	}
	if r.evals != nil {
		localVarQueryParams.Add("evals", parameterToString(*r.evals, ""))
	}
	if r.opening != nil {
		localVarQueryParams.Add("opening", parameterToString(*r.opening, ""))
	}
	if r.ongoing != nil {
		localVarQueryParams.Add("ongoing", parameterToString(*r.ongoing, ""))
	}
	if r.finished != nil {
		localVarQueryParams.Add("finished", parameterToString(*r.finished, ""))
	}
	if r.literate != nil {
		localVarQueryParams.Add("literate", parameterToString(*r.literate, ""))
	}
	if r.players != nil {
		localVarQueryParams.Add("players", parameterToString(*r.players, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-chess-pgn", "application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiUserCurrentGameRequest struct {
	ctx context.Context
	ApiService *GamesApiService
	username interface{}
	moves *interface{}
	pgnInJson *interface{}
	tags *interface{}
	clocks *interface{}
	evals *interface{}
	opening *interface{}
	literate *interface{}
	players *interface{}
}

// Include the PGN moves.
func (r ApiApiUserCurrentGameRequest) Moves(moves interface{}) ApiApiUserCurrentGameRequest {
	r.moves = &moves
	return r
}

// Include the full PGN within the JSON response, in a &#x60;pgn&#x60; field.
func (r ApiApiUserCurrentGameRequest) PgnInJson(pgnInJson interface{}) ApiApiUserCurrentGameRequest {
	r.pgnInJson = &pgnInJson
	return r
}

// Include the PGN tags.
func (r ApiApiUserCurrentGameRequest) Tags(tags interface{}) ApiApiUserCurrentGameRequest {
	r.tags = &tags
	return r
}

// Include clock comments in the PGN moves, when available.  Example: &#x60;2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }&#x60; 
func (r ApiApiUserCurrentGameRequest) Clocks(clocks interface{}) ApiApiUserCurrentGameRequest {
	r.clocks = &clocks
	return r
}

// Include analysis evaluation comments in the PGN, when available.  Example: &#x60;12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }&#x60; 
func (r ApiApiUserCurrentGameRequest) Evals(evals interface{}) ApiApiUserCurrentGameRequest {
	r.evals = &evals
	return r
}

// Include the opening name.  Example: &#x60;[Opening \&quot;King&#39;s Gambit Accepted, King&#39;s Knight Gambit\&quot;]&#x60; 
func (r ApiApiUserCurrentGameRequest) Opening(opening interface{}) ApiApiUserCurrentGameRequest {
	r.opening = &opening
	return r
}

// Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.  Example: &#x60;5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)&#x60; 
func (r ApiApiUserCurrentGameRequest) Literate(literate interface{}) ApiApiUserCurrentGameRequest {
	r.literate = &literate
	return r
}

// URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN. Example: &lt;https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt&gt; 
func (r ApiApiUserCurrentGameRequest) Players(players interface{}) ApiApiUserCurrentGameRequest {
	r.players = &players
	return r
}

func (r ApiApiUserCurrentGameRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ApiUserCurrentGameExecute(r)
}

/*
ApiUserCurrentGame Export ongoing game of a user

Download the ongoing game, or the last game played, of a user.
Available in either PGN or JSON format.
If the game is ongoing, the 3 last moves are omitted.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return ApiApiUserCurrentGameRequest
*/
func (a *GamesApiService) ApiUserCurrentGame(ctx context.Context, username interface{}) ApiApiUserCurrentGameRequest {
	return ApiApiUserCurrentGameRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return interface{}
func (a *GamesApiService) ApiUserCurrentGameExecute(r ApiApiUserCurrentGameRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GamesApiService.ApiUserCurrentGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/user/{username}/current-game"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.moves != nil {
		localVarQueryParams.Add("moves", parameterToString(*r.moves, ""))
	}
	if r.pgnInJson != nil {
		localVarQueryParams.Add("pgnInJson", parameterToString(*r.pgnInJson, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	if r.clocks != nil {
		localVarQueryParams.Add("clocks", parameterToString(*r.clocks, ""))
	}
	if r.evals != nil {
		localVarQueryParams.Add("evals", parameterToString(*r.evals, ""))
	}
	if r.opening != nil {
		localVarQueryParams.Add("opening", parameterToString(*r.opening, ""))
	}
	if r.literate != nil {
		localVarQueryParams.Add("literate", parameterToString(*r.literate, ""))
	}
	if r.players != nil {
		localVarQueryParams.Add("players", parameterToString(*r.players, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-chess-pgn", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGameImportRequest struct {
	ctx context.Context
	ApiService *GamesApiService
	pgn *interface{}
}

// The PGN. It can contain only one game. Most standard tags are supported.
func (r ApiGameImportRequest) Pgn(pgn interface{}) ApiGameImportRequest {
	r.pgn = &pgn
	return r
}

func (r ApiGameImportRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GameImportExecute(r)
}

/*
GameImport Import one game

Import a game from PGN. See <https://lichess.org/paste>.

Rate limiting: 200 games per hour for OAuth requests, 100 games per hour for anonymous requests.

To broadcast ongoing games, consider [pushing to a broadcast instead](#operation/broadcastPush).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGameImportRequest
*/
func (a *GamesApiService) GameImport(ctx context.Context) ApiGameImportRequest {
	return ApiGameImportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *GamesApiService) GameImportExecute(r ApiGameImportRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GamesApiService.GameImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.pgn != nil {
		localVarFormParams.Add("pgn", parameterToString(*r.pgn, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGamePgnRequest struct {
	ctx context.Context
	ApiService *GamesApiService
	gameId interface{}
	moves *interface{}
	pgnInJson *interface{}
	tags *interface{}
	clocks *interface{}
	evals *interface{}
	opening *interface{}
	literate *interface{}
	players *interface{}
}

// Include the PGN moves.
func (r ApiGamePgnRequest) Moves(moves interface{}) ApiGamePgnRequest {
	r.moves = &moves
	return r
}

// Include the full PGN within the JSON response, in a &#x60;pgn&#x60; field.
func (r ApiGamePgnRequest) PgnInJson(pgnInJson interface{}) ApiGamePgnRequest {
	r.pgnInJson = &pgnInJson
	return r
}

// Include the PGN tags.
func (r ApiGamePgnRequest) Tags(tags interface{}) ApiGamePgnRequest {
	r.tags = &tags
	return r
}

// Include clock comments in the PGN moves, when available.  Example: &#x60;2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }&#x60; 
func (r ApiGamePgnRequest) Clocks(clocks interface{}) ApiGamePgnRequest {
	r.clocks = &clocks
	return r
}

// Include analysis evaluation comments in the PGN, when available.  Example: &#x60;12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }&#x60; 
func (r ApiGamePgnRequest) Evals(evals interface{}) ApiGamePgnRequest {
	r.evals = &evals
	return r
}

// Include the opening name.  Example: &#x60;[Opening \&quot;King&#39;s Gambit Accepted, King&#39;s Knight Gambit\&quot;]&#x60; 
func (r ApiGamePgnRequest) Opening(opening interface{}) ApiGamePgnRequest {
	r.opening = &opening
	return r
}

// Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.  Example: &#x60;5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)&#x60; 
func (r ApiGamePgnRequest) Literate(literate interface{}) ApiGamePgnRequest {
	r.literate = &literate
	return r
}

// URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN. Example: &lt;https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt&gt; 
func (r ApiGamePgnRequest) Players(players interface{}) ApiGamePgnRequest {
	r.players = &players
	return r
}

func (r ApiGamePgnRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GamePgnExecute(r)
}

/*
GamePgn Export one game

Download one game in either PGN or JSON format.

Ongoing games have their last 3 moves omitted, after move 5.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param gameId The game ID (8 characters).
 @return ApiGamePgnRequest
*/
func (a *GamesApiService) GamePgn(ctx context.Context, gameId interface{}) ApiGamePgnRequest {
	return ApiGamePgnRequest{
		ApiService: a,
		ctx: ctx,
		gameId: gameId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *GamesApiService) GamePgnExecute(r ApiGamePgnRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GamesApiService.GamePgn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/game/export/{gameId}"
	localVarPath = strings.Replace(localVarPath, "{"+"gameId"+"}", url.PathEscape(parameterToString(r.gameId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.moves != nil {
		localVarQueryParams.Add("moves", parameterToString(*r.moves, ""))
	}
	if r.pgnInJson != nil {
		localVarQueryParams.Add("pgnInJson", parameterToString(*r.pgnInJson, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	if r.clocks != nil {
		localVarQueryParams.Add("clocks", parameterToString(*r.clocks, ""))
	}
	if r.evals != nil {
		localVarQueryParams.Add("evals", parameterToString(*r.evals, ""))
	}
	if r.opening != nil {
		localVarQueryParams.Add("opening", parameterToString(*r.opening, ""))
	}
	if r.literate != nil {
		localVarQueryParams.Add("literate", parameterToString(*r.literate, ""))
	}
	if r.players != nil {
		localVarQueryParams.Add("players", parameterToString(*r.players, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-chess-pgn", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGamesByIdsRequest struct {
	ctx context.Context
	ApiService *GamesApiService
	streamId interface{}
	body *interface{}
}

// Up to 500 or 1000 game IDs separated by commas. Example: &#x60;gameId01,gameId02,gameId03&#x60; 
func (r ApiGamesByIdsRequest) Body(body interface{}) ApiGamesByIdsRequest {
	r.body = &body
	return r
}

func (r ApiGamesByIdsRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GamesByIdsExecute(r)
}

/*
GamesByIds Stream games by IDs

Creates a stream of games from an arbitrary streamId, and a list of game IDs.

The stream first outputs the games that already exists, then emits an event each time a game is started or finished.

Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).

Maximum number of games: 500 for anonymous requests, or 1000 for [OAuth2 authenticated](#section/Authentication) requests.

While the stream is open, it is possible to [add new game IDs to watch](#operation/gamesByIdsAdd).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamId
 @return ApiGamesByIdsRequest
*/
func (a *GamesApiService) GamesByIds(ctx context.Context, streamId interface{}) ApiGamesByIdsRequest {
	return ApiGamesByIdsRequest{
		ApiService: a,
		ctx: ctx,
		streamId: streamId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *GamesApiService) GamesByIdsExecute(r ApiGamesByIdsRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GamesApiService.GamesByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/stream/games/{streamId}"
	localVarPath = strings.Replace(localVarPath, "{"+"streamId"+"}", url.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGamesByIdsAddRequest struct {
	ctx context.Context
	ApiService *GamesApiService
	streamId interface{}
	body *interface{}
}

// Up to 500 or 1000 game IDs separated by commas. Example: &#x60;gameId04,gameId05,gameId06&#x60; 
func (r ApiGamesByIdsAddRequest) Body(body interface{}) ApiGamesByIdsAddRequest {
	r.body = &body
	return r
}

func (r ApiGamesByIdsAddRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.GamesByIdsAddExecute(r)
}

/*
GamesByIdsAdd Add game IDs to stream

Add new game IDs for [an existing stream](#operation/gamesByIds) to watch.
The stream will immediately outputs the games that already exists, then emit an event each time a game is started or finished.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamId
 @return ApiGamesByIdsAddRequest
*/
func (a *GamesApiService) GamesByIdsAdd(ctx context.Context, streamId interface{}) ApiGamesByIdsAddRequest {
	return ApiGamesByIdsAddRequest{
		ApiService: a,
		ctx: ctx,
		streamId: streamId,
	}
}

// Execute executes the request
//  @return Ok
func (a *GamesApiService) GamesByIdsAddExecute(r ApiGamesByIdsAddRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GamesApiService.GamesByIdsAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/stream/games/{streamId}/add"
	localVarPath = strings.Replace(localVarPath, "{"+"streamId"+"}", url.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGamesByUsersRequest struct {
	ctx context.Context
	ApiService *GamesApiService
	body *interface{}
	withCurrentGames *interface{}
}

// Up to 300 user IDs separated by commas. Example: &#x60;aliquantus,chess-network,lovlas&#x60; 
func (r ApiGamesByUsersRequest) Body(body interface{}) ApiGamesByUsersRequest {
	r.body = &body
	return r
}

// Include the already started games at the beginning of the stream.
func (r ApiGamesByUsersRequest) WithCurrentGames(withCurrentGames interface{}) ApiGamesByUsersRequest {
	r.withCurrentGames = &withCurrentGames
	return r
}

func (r ApiGamesByUsersRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GamesByUsersExecute(r)
}

/*
GamesByUsers Stream games of users

Stream the games played between a list of users, in real time.
Only games where **both players** are part of the list are included.

The stream emits an event each time a game is started or finished.

To also get all current ongoing games at the beginning of the stream, use the `withCurrentGames` flag.

Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).

Maximum number of users: 300.

The method is `POST` so a longer list of IDs can be sent in the request body.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGamesByUsersRequest
*/
func (a *GamesApiService) GamesByUsers(ctx context.Context) ApiGamesByUsersRequest {
	return ApiGamesByUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *GamesApiService) GamesByUsersExecute(r ApiGamesByUsersRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GamesApiService.GamesByUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/stream/games-by-users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.withCurrentGames != nil {
		localVarQueryParams.Add("withCurrentGames", parameterToString(*r.withCurrentGames, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGamesExportIdsRequest struct {
	ctx context.Context
	ApiService *GamesApiService
	body *interface{}
	moves *interface{}
	pgnInJson *interface{}
	tags *interface{}
	clocks *interface{}
	evals *interface{}
	opening *interface{}
	literate *interface{}
	players *interface{}
}

// Game IDs separated by commas. Up to 300.
func (r ApiGamesExportIdsRequest) Body(body interface{}) ApiGamesExportIdsRequest {
	r.body = &body
	return r
}

// Include the PGN moves.
func (r ApiGamesExportIdsRequest) Moves(moves interface{}) ApiGamesExportIdsRequest {
	r.moves = &moves
	return r
}

// Include the full PGN within the JSON response, in a &#x60;pgn&#x60; field.
func (r ApiGamesExportIdsRequest) PgnInJson(pgnInJson interface{}) ApiGamesExportIdsRequest {
	r.pgnInJson = &pgnInJson
	return r
}

// Include the PGN tags.
func (r ApiGamesExportIdsRequest) Tags(tags interface{}) ApiGamesExportIdsRequest {
	r.tags = &tags
	return r
}

// Include clock comments in the PGN moves, when available.  Example: &#x60;2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }&#x60; 
func (r ApiGamesExportIdsRequest) Clocks(clocks interface{}) ApiGamesExportIdsRequest {
	r.clocks = &clocks
	return r
}

// Include analysis evaluation comments in the PGN, when available.  Example: &#x60;12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }&#x60; 
func (r ApiGamesExportIdsRequest) Evals(evals interface{}) ApiGamesExportIdsRequest {
	r.evals = &evals
	return r
}

// Include the opening name.  Example: &#x60;[Opening \&quot;King&#39;s Gambit Accepted, King&#39;s Knight Gambit\&quot;]&#x60; 
func (r ApiGamesExportIdsRequest) Opening(opening interface{}) ApiGamesExportIdsRequest {
	r.opening = &opening
	return r
}

// Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.  Example: &#x60;5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)&#x60; 
func (r ApiGamesExportIdsRequest) Literate(literate interface{}) ApiGamesExportIdsRequest {
	r.literate = &literate
	return r
}

// URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN. Example: &lt;https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt&gt; 
func (r ApiGamesExportIdsRequest) Players(players interface{}) ApiGamesExportIdsRequest {
	r.players = &players
	return r
}

func (r ApiGamesExportIdsRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.GamesExportIdsExecute(r)
}

/*
GamesExportIds Export games by IDs

Download games by IDs in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request Accept header.

Games are sorted by reverse chronological order (most recent first)

The method is `POST` so a longer list of IDs can be sent in the request body.

300 IDs can be submitted.

Ongoing games have their last 3 moves omitted, after move 5.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGamesExportIdsRequest
*/
func (a *GamesApiService) GamesExportIds(ctx context.Context) ApiGamesExportIdsRequest {
	return ApiGamesExportIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *GamesApiService) GamesExportIdsExecute(r ApiGamesExportIdsRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GamesApiService.GamesExportIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/games/export/_ids"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.moves != nil {
		localVarQueryParams.Add("moves", parameterToString(*r.moves, ""))
	}
	if r.pgnInJson != nil {
		localVarQueryParams.Add("pgnInJson", parameterToString(*r.pgnInJson, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	if r.clocks != nil {
		localVarQueryParams.Add("clocks", parameterToString(*r.clocks, ""))
	}
	if r.evals != nil {
		localVarQueryParams.Add("evals", parameterToString(*r.evals, ""))
	}
	if r.opening != nil {
		localVarQueryParams.Add("opening", parameterToString(*r.opening, ""))
	}
	if r.literate != nil {
		localVarQueryParams.Add("literate", parameterToString(*r.literate, ""))
	}
	if r.players != nil {
		localVarQueryParams.Add("players", parameterToString(*r.players, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-chess-pgn", "application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStreamGameRequest struct {
	ctx context.Context
	ApiService *GamesApiService
	id interface{}
}

func (r ApiStreamGameRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.StreamGameExecute(r)
}

/*
StreamGame Stream moves of a game

Stream positions and moves of any ongoing game, in [ndjson](#section/Introduction/Streaming-with-ND-JSON).

A description of the game is sent as a first message.
Then a message is sent each time a move is played.
Finally a description of the game is sent when it finishes, and the stream is closed.

After move 5, the stream intentionally remains 3 moves behind the game status, as to prevent cheat bots from using this API.

No more than 8 game streams can be opened at the same time from the same IP address.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiStreamGameRequest
*/
func (a *GamesApiService) StreamGame(ctx context.Context, id interface{}) ApiStreamGameRequest {
	return ApiStreamGameRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *GamesApiService) StreamGameExecute(r ApiStreamGameRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GamesApiService.StreamGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/stream/game/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
