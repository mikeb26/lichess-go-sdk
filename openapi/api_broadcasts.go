/*
Lichess.org API reference

# Introduction Welcome to the reference for the Lichess API! Lichess is free/libre, open-source chess server powered by volunteers and donations. - Get help in the [Lichess Discord channel](https://discord.gg/lichess) - API demo app with OAuth2 login, gameplay, and more: [source](https://github.com/lichess-org/api-demo) / [demo](https://lichess-org.github.io/api-demo/) - [Contribute to this documentation on Github](https://github.com/lichess-org/api) - Check out [Lichess widgets to embed in your website](https://lichess.org/developers) - [Download all Lichess rated games](https://database.lichess.org/) - [Download all Lichess puzzles with themes, ratings and votes](https://database.lichess.org/#puzzles)  ## Endpoint All requests go to `https://lichess.org` (unless otherwise specified).  ## Clients - [Python general API](https://github.com/ZackClements/berserk) - [MicroPython general API](https://github.com/mkomon/uberserk) - [Python general API - async](https://pypi.org/project/async-lichess-sdk) - [Python Lichess Bot](https://github.com/ShailChoksi/lichess-bot) - [Python Board API for Certabo](https://github.com/haklein/certabo-lichess) - [Java general API](https://github.com/tors42/chariot)  ## Rate limiting All requests are rate limited using various strategies, to ensure the API remains responsive for everyone. Only make one request at a time. If you receive an HTTP response with a [429 status](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429), please wait a full minute before resuming API usage.  ## Streaming with ND-JSON Some API endpoints stream their responses as [Newline Delimited JSON a.k.a. **nd-json**](http://ndjson.org/), with one JSON object per line.  Here's a [JavaScript utility function](https://gist.github.com/ornicar/a097406810939cf7be1df8ea30e94f3e) to help reading NDJSON streamed responses. 

API version: 2.0.0
Contact: contact@lichess.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// BroadcastsApiService BroadcastsApi service
type BroadcastsApiService service

type ApiBroadcastAllRoundsPgnRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	broadcastTournamentId interface{}
}

func (r ApiBroadcastAllRoundsPgnRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.BroadcastAllRoundsPgnExecute(r)
}

/*
BroadcastAllRoundsPgn Export all rounds as PGN

Download all games of all rounds of a broadcast in PGN format.

You may want to [download only the games of a single round](#operation/broadcastRoundPgn) instead.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param broadcastTournamentId The broadcast tournament ID (8 characters).
 @return ApiBroadcastAllRoundsPgnRequest
*/
func (a *BroadcastsApiService) BroadcastAllRoundsPgn(ctx context.Context, broadcastTournamentId interface{}) ApiBroadcastAllRoundsPgnRequest {
	return ApiBroadcastAllRoundsPgnRequest{
		ApiService: a,
		ctx: ctx,
		broadcastTournamentId: broadcastTournamentId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *BroadcastsApiService) BroadcastAllRoundsPgnExecute(r ApiBroadcastAllRoundsPgnRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastAllRoundsPgn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/broadcast/{broadcastTournamentId}.pgn"
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastTournamentId"+"}", url.PathEscape(parameterToString(r.broadcastTournamentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-chess-pgn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastIndexRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	nb *interface{}
}

// Max number of broadcasts to fetch
func (r ApiBroadcastIndexRequest) Nb(nb interface{}) ApiBroadcastIndexRequest {
	r.nb = &nb
	return r
}

func (r ApiBroadcastIndexRequest) Execute() ([]interface{}, *http.Response, error) {
	return r.ApiService.BroadcastIndexExecute(r)
}

/*
BroadcastIndex Get official broadcasts

Get all incoming, ongoing, and finished official broadcasts.
The broadcasts are sorted by start date, most recent first.

Broadcasts are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBroadcastIndexRequest
*/
func (a *BroadcastsApiService) BroadcastIndex(ctx context.Context) ApiBroadcastIndexRequest {
	return ApiBroadcastIndexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []interface{}
func (a *BroadcastsApiService) BroadcastIndexExecute(r ApiBroadcastIndexRequest) ([]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/broadcast"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nb != nil {
		localVarQueryParams.Add("nb", parameterToString(*r.nb, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastPushRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	broadcastRoundId interface{}
	body *interface{}
}

// The PGN. It can contain up to 64 games, separated by a double new line.
func (r ApiBroadcastPushRequest) Body(body interface{}) ApiBroadcastPushRequest {
	r.body = &body
	return r
}

func (r ApiBroadcastPushRequest) Execute() ([]Ok, *http.Response, error) {
	return r.ApiService.BroadcastPushExecute(r)
}

/*
BroadcastPush Push PGN to your broadcast round

Update your broadcast with new PGN.
Only for broadcast without a source URL.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param broadcastRoundId The broadcast round ID (8 characters).
 @return ApiBroadcastPushRequest
*/
func (a *BroadcastsApiService) BroadcastPush(ctx context.Context, broadcastRoundId interface{}) ApiBroadcastPushRequest {
	return ApiBroadcastPushRequest{
		ApiService: a,
		ctx: ctx,
		broadcastRoundId: broadcastRoundId,
	}
}

// Execute executes the request
//  @return []Ok
func (a *BroadcastsApiService) BroadcastPushExecute(r ApiBroadcastPushRequest) ([]Ok, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastPush")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/broadcast/round/{broadcastRoundId}/push"
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastRoundId"+"}", url.PathEscape(parameterToString(r.broadcastRoundId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastRoundCreateRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	broadcastTournamentId interface{}
	name *interface{}
	syncUrl *interface{}
	startsAt *interface{}
}

// Name of the broadcast round. Length must be between 3 and 80 characters.  Example: &#x60;Round 1&#x60; 
func (r ApiBroadcastRoundCreateRequest) Name(name interface{}) ApiBroadcastRoundCreateRequest {
	r.name = &name
	return r
}

// URL that Lichess will poll to get updates about the games. It must be publicly accessible from the Internet.  Example: &#x60;https://myserver.org/myevent/round-10/games.pgn&#x60;  If the syncUrl is missing, then the broadcast needs to be fed by [pushing PGN to it](#operation/broadcastPush). 
func (r ApiBroadcastRoundCreateRequest) SyncUrl(syncUrl interface{}) ApiBroadcastRoundCreateRequest {
	r.syncUrl = &syncUrl
	return r
}

// Timestamp in milliseconds of broadcast round start. Leave empty to manually start the broadcast round.  Example: &#x60;1356998400070&#x60; 
func (r ApiBroadcastRoundCreateRequest) StartsAt(startsAt interface{}) ApiBroadcastRoundCreateRequest {
	r.startsAt = &startsAt
	return r
}

func (r ApiBroadcastRoundCreateRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.BroadcastRoundCreateExecute(r)
}

/*
BroadcastRoundCreate Create a broadcast round

Create a new broadcast round to relay external games.
This endpoint accepts the same form data as the web form.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param broadcastTournamentId The broadcast tournament ID (8 characters).
 @return ApiBroadcastRoundCreateRequest
*/
func (a *BroadcastsApiService) BroadcastRoundCreate(ctx context.Context, broadcastTournamentId interface{}) ApiBroadcastRoundCreateRequest {
	return ApiBroadcastRoundCreateRequest{
		ApiService: a,
		ctx: ctx,
		broadcastTournamentId: broadcastTournamentId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *BroadcastsApiService) BroadcastRoundCreateExecute(r ApiBroadcastRoundCreateRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastRoundCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/broadcast/{broadcastTournamentId}/new"
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastTournamentId"+"}", url.PathEscape(parameterToString(r.broadcastTournamentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	if r.syncUrl != nil {
		localVarFormParams.Add("syncUrl", parameterToString(*r.syncUrl, ""))
	}
	if r.startsAt != nil {
		localVarFormParams.Add("startsAt", parameterToString(*r.startsAt, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastRoundGetRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	broadcastTournamentSlug interface{}
	broadcastRoundSlug interface{}
	broadcastRoundId interface{}
}

func (r ApiBroadcastRoundGetRequest) Execute() ([]interface{}, *http.Response, error) {
	return r.ApiService.BroadcastRoundGetExecute(r)
}

/*
BroadcastRoundGet Get your broadcast round

Get information about a broadcast round.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param broadcastTournamentSlug The broadcast tournament slug. Only used for SEO, the slug can be safely replaced by `-`. Only the `broadcastRoundId` is actually used.
 @param broadcastRoundSlug The broadcast round slug. Only used for SEO, the slug can be safely replaced by `-`. Only the `broadcastRoundId` is actually used.
 @param broadcastRoundId The broadcast Round ID (8 characters).
 @return ApiBroadcastRoundGetRequest
*/
func (a *BroadcastsApiService) BroadcastRoundGet(ctx context.Context, broadcastTournamentSlug interface{}, broadcastRoundSlug interface{}, broadcastRoundId interface{}) ApiBroadcastRoundGetRequest {
	return ApiBroadcastRoundGetRequest{
		ApiService: a,
		ctx: ctx,
		broadcastTournamentSlug: broadcastTournamentSlug,
		broadcastRoundSlug: broadcastRoundSlug,
		broadcastRoundId: broadcastRoundId,
	}
}

// Execute executes the request
//  @return []interface{}
func (a *BroadcastsApiService) BroadcastRoundGetExecute(r ApiBroadcastRoundGetRequest) ([]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastRoundGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/broadcast/{broadcastTournamentSlug}/{broadcastRoundSlug}/{broadcastRoundId}"
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastTournamentSlug"+"}", url.PathEscape(parameterToString(r.broadcastTournamentSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastRoundSlug"+"}", url.PathEscape(parameterToString(r.broadcastRoundSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastRoundId"+"}", url.PathEscape(parameterToString(r.broadcastRoundId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastRoundPgnRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	broadcastRoundId interface{}
}

func (r ApiBroadcastRoundPgnRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.BroadcastRoundPgnExecute(r)
}

/*
BroadcastRoundPgn Export one round as PGN

Download all games of a single round of a broadcast tournament in PGN format.

You *could* poll this endpoint to get updates about a tournament, but it would be slow,
and very inneficient.

Instead, consider [streaming the tournament](#operation/broadcastStreamRoundPgn) to get
a new PGN every time a game is updated, in real-time.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param broadcastRoundId The round ID (8 characters).
 @return ApiBroadcastRoundPgnRequest
*/
func (a *BroadcastsApiService) BroadcastRoundPgn(ctx context.Context, broadcastRoundId interface{}) ApiBroadcastRoundPgnRequest {
	return ApiBroadcastRoundPgnRequest{
		ApiService: a,
		ctx: ctx,
		broadcastRoundId: broadcastRoundId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *BroadcastsApiService) BroadcastRoundPgnExecute(r ApiBroadcastRoundPgnRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastRoundPgn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/broadcast/round/{broadcastRoundId}.pgn"
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastRoundId"+"}", url.PathEscape(parameterToString(r.broadcastRoundId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-chess-pgn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastRoundUpdateRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	broadcastRoundId interface{}
	name *interface{}
	syncUrl *interface{}
	startsAt *interface{}
}

// Name of the broadcast round. Length must be between 3 and 80 characters.  Example: &#x60;Round 10&#x60; 
func (r ApiBroadcastRoundUpdateRequest) Name(name interface{}) ApiBroadcastRoundUpdateRequest {
	r.name = &name
	return r
}

// URL that Lichess will poll to get updates about the games. It must be publicly accessible from the Internet.  Example: &#x60;https://myserver.org/myevent/round-10/games.pgn&#x60; 
func (r ApiBroadcastRoundUpdateRequest) SyncUrl(syncUrl interface{}) ApiBroadcastRoundUpdateRequest {
	r.syncUrl = &syncUrl
	return r
}

// Timestamp in milliseconds of broadcast start. Leave empty to manually start the broadcast.  Example: &#x60;1356998400070&#x60; 
func (r ApiBroadcastRoundUpdateRequest) StartsAt(startsAt interface{}) ApiBroadcastRoundUpdateRequest {
	r.startsAt = &startsAt
	return r
}

func (r ApiBroadcastRoundUpdateRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.BroadcastRoundUpdateExecute(r)
}

/*
BroadcastRoundUpdate Update your broadcast round

Update information about a broadcast round that you created.
This endpoint accepts the same form data as the web form.
All fields must be populated with data. Missing fields will override the broadcast with empty data.
For instance, if you omit `startDate`, then any pre-existing start date will be removed.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param broadcastRoundId The broadcast round ID (8 characters).
 @return ApiBroadcastRoundUpdateRequest
*/
func (a *BroadcastsApiService) BroadcastRoundUpdate(ctx context.Context, broadcastRoundId interface{}) ApiBroadcastRoundUpdateRequest {
	return ApiBroadcastRoundUpdateRequest{
		ApiService: a,
		ctx: ctx,
		broadcastRoundId: broadcastRoundId,
	}
}

// Execute executes the request
//  @return Ok
func (a *BroadcastsApiService) BroadcastRoundUpdateExecute(r ApiBroadcastRoundUpdateRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastRoundUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/broadcast/round/{broadcastRoundId}/edit"
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastRoundId"+"}", url.PathEscape(parameterToString(r.broadcastRoundId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	if r.syncUrl != nil {
		localVarFormParams.Add("syncUrl", parameterToString(*r.syncUrl, ""))
	}
	if r.startsAt != nil {
		localVarFormParams.Add("startsAt", parameterToString(*r.startsAt, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastStreamRoundPgnRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	broadcastRoundId interface{}
}

func (r ApiBroadcastStreamRoundPgnRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.BroadcastStreamRoundPgnExecute(r)
}

/*
BroadcastStreamRoundPgn Stream an ongoing broadcast tournament as PGN

This streaming endpoint first sends all games of a broadcast tournament in PGN format.

Then, it waits for new moves to be played. As soon as it happens, the entire PGN of the game is sent to the stream.

The stream will also send PGNs when games are added to the tournament.

This is the best way to get updates about an ongoing tournament. Streaming means no polling,
and no pollings means no latency, and minimum impact on the server.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param broadcastRoundId The broadcast round ID (8 characters).
 @return ApiBroadcastStreamRoundPgnRequest
*/
func (a *BroadcastsApiService) BroadcastStreamRoundPgn(ctx context.Context, broadcastRoundId interface{}) ApiBroadcastStreamRoundPgnRequest {
	return ApiBroadcastStreamRoundPgnRequest{
		ApiService: a,
		ctx: ctx,
		broadcastRoundId: broadcastRoundId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *BroadcastsApiService) BroadcastStreamRoundPgnExecute(r ApiBroadcastStreamRoundPgnRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastStreamRoundPgn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/stream/broadcast/round/{broadcastRoundId}.pgn"
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastRoundId"+"}", url.PathEscape(parameterToString(r.broadcastRoundId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-chess-pgn"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastTourCreateRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	name *interface{}
	description *interface{}
	markdown *interface{}
	official *interface{}
}

// Name of the broadcast tournament. Length must be between 3 and 80 characters.  Example: &#x60;Sinquefield Cup&#x60; 
func (r ApiBroadcastTourCreateRequest) Name(name interface{}) ApiBroadcastTourCreateRequest {
	r.name = &name
	return r
}

// Short description of the broadcast tournament. Length must be between 3 and 400 characters.  Example: &#x60;An 11 round classical tournament featuring the 9 highest rated players in the world. Including Carlsen, Caruana, Ding, Aronian, Nakamura and more.&#x60; 
func (r ApiBroadcastTourCreateRequest) Description(description interface{}) ApiBroadcastTourCreateRequest {
	r.description = &description
	return r
}

// Optional long description of the broadcast. Markdown is supported. Length must be less than 20,000 characters.
func (r ApiBroadcastTourCreateRequest) Markdown(markdown interface{}) ApiBroadcastTourCreateRequest {
	r.markdown = &markdown
	return r
}

// For Lichess internal usage only. You are not allowed to use this flag. If you do it, we will have to call the police.
func (r ApiBroadcastTourCreateRequest) Official(official interface{}) ApiBroadcastTourCreateRequest {
	r.official = &official
	return r
}

func (r ApiBroadcastTourCreateRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.BroadcastTourCreateExecute(r)
}

/*
BroadcastTourCreate Create a broadcast tournament

Create a new broadcast tournament to relay external games.
This endpoint accepts the same form data as the [web form](https://lichess.org/broadcast/new).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBroadcastTourCreateRequest
*/
func (a *BroadcastsApiService) BroadcastTourCreate(ctx context.Context) ApiBroadcastTourCreateRequest {
	return ApiBroadcastTourCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *BroadcastsApiService) BroadcastTourCreateExecute(r ApiBroadcastTourCreateRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastTourCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/broadcast/new"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	localVarFormParams.Add("description", parameterToString(*r.description, ""))
	if r.markdown != nil {
		localVarFormParams.Add("markdown", parameterToString(*r.markdown, ""))
	}
	if r.official != nil {
		localVarFormParams.Add("official", parameterToString(*r.official, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastTourGetRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	slug interface{}
	broadcastTournamentId interface{}
}

func (r ApiBroadcastTourGetRequest) Execute() ([]interface{}, *http.Response, error) {
	return r.ApiService.BroadcastTourGetExecute(r)
}

/*
BroadcastTourGet Get your broadcast tournament

Get information about a broadcast tournament.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param slug The broadcast tournament slug. Only used for SEO, the slug can be safely replaced by `-`. Only the `broadcastTournamentId` is actually used.
 @param broadcastTournamentId The broadcast tournament ID (8 characters).
 @return ApiBroadcastTourGetRequest
*/
func (a *BroadcastsApiService) BroadcastTourGet(ctx context.Context, slug interface{}, broadcastTournamentId interface{}) ApiBroadcastTourGetRequest {
	return ApiBroadcastTourGetRequest{
		ApiService: a,
		ctx: ctx,
		slug: slug,
		broadcastTournamentId: broadcastTournamentId,
	}
}

// Execute executes the request
//  @return []interface{}
func (a *BroadcastsApiService) BroadcastTourGetExecute(r ApiBroadcastTourGetRequest) ([]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastTourGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/broadcast/{slug}/{broadcastTournamentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"slug"+"}", url.PathEscape(parameterToString(r.slug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastTournamentId"+"}", url.PathEscape(parameterToString(r.broadcastTournamentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBroadcastTourUpdateRequest struct {
	ctx context.Context
	ApiService *BroadcastsApiService
	broadcastTournamentId interface{}
	name *interface{}
	description *interface{}
	markdown *interface{}
	official *interface{}
}

// Name of the broadcast tournament. Length must be between 3 and 80 characters.  Example: &#x60;Sinquefield Cup&#x60; 
func (r ApiBroadcastTourUpdateRequest) Name(name interface{}) ApiBroadcastTourUpdateRequest {
	r.name = &name
	return r
}

// Short description of the broadcast tournament. Length must be between 3 and 400 characters.  Example: &#x60;An 11 round classical tournament featuring the 9 highest rated players in the world. Including Carlsen, Caruana, Ding, Aronian, Nakamura and more.&#x60; 
func (r ApiBroadcastTourUpdateRequest) Description(description interface{}) ApiBroadcastTourUpdateRequest {
	r.description = &description
	return r
}

// Optional long description of the broadcast tournament. Markdown is supported. Length must be less than 20,000 characters.
func (r ApiBroadcastTourUpdateRequest) Markdown(markdown interface{}) ApiBroadcastTourUpdateRequest {
	r.markdown = &markdown
	return r
}

// For Lichess internal usage only. You are not allowed to use this flag. If you do it, we will have to call the police.
func (r ApiBroadcastTourUpdateRequest) Official(official interface{}) ApiBroadcastTourUpdateRequest {
	r.official = &official
	return r
}

func (r ApiBroadcastTourUpdateRequest) Execute() (*Ok, *http.Response, error) {
	return r.ApiService.BroadcastTourUpdateExecute(r)
}

/*
BroadcastTourUpdate Update your broadcast tournament

Update information about a broadcast tournament that you created.
This endpoint accepts the same form data as the web form.
All fields must be populated with data. Missing fields will override the broadcast with empty data.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param broadcastTournamentId The broadcast ID (8 characters).
 @return ApiBroadcastTourUpdateRequest
*/
func (a *BroadcastsApiService) BroadcastTourUpdate(ctx context.Context, broadcastTournamentId interface{}) ApiBroadcastTourUpdateRequest {
	return ApiBroadcastTourUpdateRequest{
		ApiService: a,
		ctx: ctx,
		broadcastTournamentId: broadcastTournamentId,
	}
}

// Execute executes the request
//  @return Ok
func (a *BroadcastsApiService) BroadcastTourUpdateExecute(r ApiBroadcastTourUpdateRequest) (*Ok, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ok
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BroadcastsApiService.BroadcastTourUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/broadcast/{broadcastTournamentId}/edit"
	localVarPath = strings.Replace(localVarPath, "{"+"broadcastTournamentId"+"}", url.PathEscape(parameterToString(r.broadcastTournamentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(*r.name, ""))
	localVarFormParams.Add("description", parameterToString(*r.description, ""))
	if r.markdown != nil {
		localVarFormParams.Add("markdown", parameterToString(*r.markdown, ""))
	}
	if r.official != nil {
		localVarFormParams.Add("official", parameterToString(*r.official, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
